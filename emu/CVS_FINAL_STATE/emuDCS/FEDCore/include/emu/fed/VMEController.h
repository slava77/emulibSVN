/*****************************************************************************\
* $Id: VMEController.h,v 1.7 2009/12/10 16:24:29 paste Exp $
\*****************************************************************************/
#ifndef __EMU_FED_VMECONTROLLER_H__
#define __EMU_FED_VMECONTROLLER_H__

#include "emu/fed/Exception.h"
#include "emu/fed/VMELock.h"

namespace emu {

	namespace fed {

		/** @class VMEController A base class for a device that establishes communication with a CAEN VME controller **/
		class VMEController
		{
		public:

			/** Default constructor.
			*
			*	@param Device the PCI device number.
			*	@param Link the position of the target controller in a daisy chain.
			**/
			VMEController(const int &Device, const int &Link, const bool &fake = false)
			throw (emu::fed::exception::CAENException);

			/** Default destructor. **/
			virtual ~VMEController();

			/** @returns the device number. **/
			inline int getDevice() { return Device_; }

			/** @returns the link number. **/
			inline int getLink() { return Link_; }

			/** @returns the CAEN BHandle, **/
			inline int32_t getBHandle() { return BHandle_; }
			
			/** @returns a pointer to the mutex for this controller. **/
			inline VMELock *getMutex() { return mutex_; }

			/** Set the IRQ enabled and wait until an interrupt comes through.
			*
			*	@param mSecs the number of milliseconds to wait for an
			*	interrupt before exiting with all clear status.
			*
			*	@returns false if there was an interrupt set, true otherwise.
			**/
			virtual bool waitIRQ(const unsigned int &mSecs = 5000)
			throw (emu::fed::exception::CAENException);

			/** Read the VME IRQ channel
			*
			*	@returns the 16-bits read from the IRQ channel.
			**/
			virtual uint16_t readIRQ()
			throw (emu::fed::exception::CAENException);

			/**	I am doing something smart here.  Instead of making the BHandles extern,
			*	I am going to have the original constructor set its own BHanlde to a
			*	crazy value in case of an error.  Thus, if the device is already open, I
			*	will be able to check the BHandle to figure that out, then simply replace
			*	the BHandle with the correct value once I know it.
			**/
			inline void setBHandle(const int32_t &BHandle) { BHandle_ = BHandle; }
			
			/** @returns false if the controller is connected to a crate and can communicate. **/
			inline bool isFake() { return fake_; }
			
			/** Sets whether the controller is connected to a crate or not. **/
			void setFake(const bool &fake)
			throw (emu::fed::exception::CAENException);
			
		protected:
			/// A mutex for atomizing communication with the controller.
			VMELock *mutex_;

		private:

			/// The device number.  One driver instance controls all the CAEN PCI boards on a machine, so this number chooses to which CAEN board communication will be addressed.
			int Device_;

			/// The daisy-chain link number.  The controllers can be connected in a daisy-chain fashion, with the transmit line of one plugged into the receive line of the next.  This chooses which device in the daisy-chain to address.
			int Link_;

			/// The BHandle.  This is a unique number generated by the driver and used to pick which Device/Link pair a given command addresses.
			int32_t BHandle_;

			/// If the controller can communicate with a real crate, this should be false.
			bool fake_;

		};

	}
}

#endif

