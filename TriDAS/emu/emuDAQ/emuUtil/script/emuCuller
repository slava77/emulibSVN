#!/usr/bin/python2.4
# -*- coding: utf-8 -*-

# index = { keyPhrase : { articleStart : articleLength } }
# keyPhrase runs over all key phrases' all possible variants generated by the optional parts.
# { articleStart : articleLength } runs over all articles in which keyPhrase occurs.

import re
import os
import datetime

from xml.dom.ext.reader import Sax2
from xml.dom import Node
from xml.dom import ext
import StringIO

import sys

################
class emuCuller:
################
    
    def __init__(self,doc):
        self._reader      = Sax2.Reader()
        self._doc         = self._reader.fromStream( StringIO.StringIO(doc) )
        # For normalizing white space and new lines
        self._multipleWhiteSpace = re.compile('\s\s+',re.U) # multiple occurence of white space char
        self._leadingWhiteSpace  = re.compile('^\s',re.U)   # leading white space
        self._trailingWhiteSpace = re.compile('\s$',re.U)   # trailing white space
        # For pretty print
        self._recursionDepth = 0
        self._indentUnit     = '  '
        # For selecting
        self._excludedContexts    = set()
        self._excludedAppsWithI2O = set()
    
    def normalizeWhiteSpace(self, string):
        """Shrink multiple white space and remove leading and trailing white space"""
        normalized = self._multipleWhiteSpace.sub( ' ', string )
        normalized = self._leadingWhiteSpace.sub( '', normalized )
        normalized = self._trailingWhiteSpace.sub( '', normalized )
        return normalized

    def dropElement(self,node):
        """Determine whether or not to exclude this element (and its descendants) from the new congiguration."""
        if node in self._excludedContexts:
            return True
        if node.tagName == 'i2o:target':
            for app in self._excludedAppsWithI2O:
                if node.getAttribute('class') == app.getAttribute('class') and node.getAttribute('instance') == app.getAttribute('instance'):
                    return True
        return False
            

    def reconstructRecursively(self,node,pretty=True):
        """Reconstruct the article from the DOM tree, omitting elements to be excluded"""
        result = u''
        if node.nodeType == Node.DOCUMENT_NODE:
            for c in node.childNodes:
                result += self.reconstructRecursively(c,pretty)
        elif node.nodeType == Node.DOCUMENT_TYPE_NODE:
            pass
        elif node.nodeType == Node.PROCESSING_INSTRUCTION_NODE:
            if pretty:
                result += self._recursionDepth * self._indentUnit + '<?' + node.nodeName + ' ' + node.nodeValue + '?>\n'
            else:
                result += '<?' + node.nodeValue + '?>'
            return result
        elif node.nodeType == Node.COMMENT_NODE:
            if pretty:
                result += self._recursionDepth * self._indentUnit + '<!--' + node.nodeValue + '-->\n'
            else:
                result += '<!--' + node.nodeValue + '-->'
            return result
        elif node.nodeType == Node.ELEMENT_NODE:
            #
            # Is this node (and its descendants) to be displayed?
            #
            if self.dropElement( node ):
                return result
            #
            # start tag:
            #
            as = u''
            if node.attributes:
                for a in node.attributes:
                    as += ' '+a.name+'="'+a.value+'"'
            if node.nodeType <> Node.TEXT_NODE:
                if pretty:
                    result += self._recursionDepth * self._indentUnit + '<'+node.nodeName+as+'>' + '\n'
                else:
                    result += '<'+node.nodeName+as+'>'
            #
            # child elements:
            #
            self._recursionDepth += 1
            for c in node.childNodes:
                if c.nodeType == Node.TEXT_NODE:
                    text = self.normalizeWhiteSpace( c.data )
                    if len(text.encode('UTF-8')):
                        if pretty:
                            result += self._recursionDepth * self._indentUnit + text + '\n'
                        else:
                            result += text
                else:
                    result += self.reconstructRecursively(c,pretty)
            self._recursionDepth -= 1
            #
            # end tag:
            #
            if node.nodeType <> Node.TEXT_NODE:
                if pretty:
                    result += self._recursionDepth * self._indentUnit + '</'+node.nodeName+'>' + '\n'
                else:
                    result += '</'+node.nodeName+'>'
        return result
    
    def printAll(self):
        """Debug print to check the recursive reconstruction of XML from DOM."""
        #ext.PrettyPrint(self._doc)
        print "<?xml version='1.0'?>"
        print self.reconstructRecursively(self._doc).encode('UTF-8')

    def getContextOf(self, chamber):
        """Find out which context this element is in."""
        elem = chamber
        while elem.parentNode:
            if elem.nodeName == 'xc:Context':
                return elem
            elem = elem.parentNode
            
    def collectExcludedAppsWithI2O(self):
        """Find all the applications using I2O that are in the contexts to be excluded."""
        for c in self._excludedContexts:
            for app in c.getElementsByTagName('xc:Application'):
                if app.getAttribute('class') in [ 'EmuRUI', 'RU', 'BU', 'EmuFU' ]:
                    self._excludedAppsWithI2O.add( app )

    def collectExcludedContexts(self, chambersIn, chambersOut):
        """Find all the contexts to be excluded, based on which chambers' data they handle."""
        allReaderContexts  = set()
        keepContexts = set()
        dropContexts = set()
        # all contexts
        for c in self._doc.getElementsByTagName('xc:Context'):
            if len( c.getElementsByTagName('chamberNames') ) > 0:
                allReaderContexts.add( c )
        # contexts to keep or drop
        for cn in self._doc.getElementsByTagName('chamberNames'):
            for i in cn.getElementsByTagName('item'):
                for c in i.childNodes:
                    if c.nodeType == Node.TEXT_NODE:
                        txt = self.normalizeWhiteSpace( c.data ).lower()
                        if   txt in chambersIn:
                            keepContexts.add( self.getContextOf( cn ) )
                        elif txt in chambersOut:
                            dropContexts.add( self.getContextOf( cn ) )
        #print 'allReaderContexts',allReaderContexts
        #print 'keepContexts',keepContexts
        #print 'dropContexts',dropContexts
        if len( chambersIn ) == 0 and len( chambersOut ) == 0:
            pass
        if len( chambersIn ) > 0 and len( chambersOut ) > 0:
            pass
        elif len( chambersIn ) > 0:
            self._excludedContexts = allReaderContexts.difference( keepContexts )
        elif len( chambersOut ) > 0:
            self._excludedContexts = dropContexts
        print 'Excluding:'
        for ec in self._excludedContexts:
            m = re.match('(http://)(.*:[0-9]*$)',ec.getAttribute('url'))
            print (30-len(m.group(2)))*' ',m.group(2)


    def cull(self, chambersIn, chambersOut):
        """Create and return the new configuration XML containing the requested chambers only."""
        self.collectExcludedContexts(chambersIn, chambersOut)
        self.collectExcludedAppsWithI2O()
        return self.reconstructRecursively(self._doc).encode('UTF-8')

def printHelp():
    print """
emuCuller removes chambers from the complete local EmuDAQ farm.

    Usage:
        emuCuller [-c complete_config] [-n new_config] [ -k chambers_to_keep | -r chambers_to_remove ] [-h]

    Options:
        -c    Complete configuration file's name. Default is 'EmuDAQ_SliceTest_Complete.xml'.
        -n    New configuration file's name. Default is 'EmuDAQ_SliceTest.xml'.
        -k    Comma-separated list of chambers to keep in the configuration. (All others will be removed.)
              Names are case-insensitive. Default is empty list.
        -r    Comma-separated list of chambers to remove from the complete configuration.
              Names are case-insensitive. Default is empty list.
        -h    Print this help.

    Examples:
        emuCuller -n EmuDAQ_ME1_only.xml -k me1a,me1b
        emuCuller -n EmuDAQ_ME3_out.xml -r Me3
        emuCuller -n Copy_of_EmuDAQ_SliceTest_Complete.xml 
"""

if __name__ == "__main__":
    
    # user is clueless
    if len(sys.argv) == 1:
        printHelp()
        sys.exit(0)

    # default arguments
    completeConfigFileName = 'EmuDAQ_SliceTest_Complete.xml'
    newConfigFileName      = "EmuDAQ_SliceTest.xml"
    chambersIn  = []
    chambersOut = []

    # user's command line options
    for i in range(1,len(sys.argv)):
        if sys.argv[i] == '-m':
            completeConfigFileName = sys.argv[i+1]
        elif sys.argv[i] == '-n':
            newConfigFileName = sys.argv[i+1]
        elif sys.argv[i] == '-k':
            if i+1 < len(sys.argv):
                chambersIn = re.split(',',sys.argv[i+1].lower())
        elif sys.argv[i] == '-r':
            if i+1 < len(sys.argv):
                chambersOut = re.split(',',sys.argv[i+1].lower())
        elif sys.argv[i] == '-h':
            printHelp()
            sys.exit(0)

    # read in the complete configuration
    try:
        completeConfigFile = open(completeConfigFileName,'r')
    except:
        print '***** Error opening',completeConfigFileName
        sys.exit(1)
    completeConfigXML = completeConfigFile.read()

    # sort them out
    culler = emuCuller( completeConfigXML )
    #culler.printAll()
    user = 'UNKNOWN_USER'
    host = 'UNKNOWN_HOST'
    pwd  = 'UNKNOWN_DIR'
    time = str(datetime.datetime.utcnow())
    if 'USER' in os.environ:
        user = os.environ['USER']
    if 'HOST' in os.environ:
        host = os.environ['HOST']
    if 'PWD' in os.environ:
        pwd = os.environ['PWD']
    newConfigXML  = "<?xml version='1.0'?>\n"
    newConfigXML += "<!-- Generated by emuCuller from "+user+'@'+host+':'+pwd+'/'+completeConfigFileName+' at '+time+" UTC -->\n"
    newConfigXML += culler.cull( chambersIn, chambersOut )

    # save the new configuration
    try:
        newConfigFile = open(newConfigFileName,'w')
    except:
        print '***** Error opening',newConfigFileName
        sys.exit(1)
    try:
        newConfigFile.write( newConfigXML )
    except:
        print '***** Error writing',newConfigFileName
        sys.exit(1)
    print '\nWrote',newConfigFileName
