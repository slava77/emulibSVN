#!/usr/bin/python2.4
# -*- coding: utf-8 -*-

import re
import os
import datetime

from xml.dom.ext.reader import Sax2
from xml.dom import Node
from xml.dom import ext
import StringIO

import sys

################
class emuCuller:
################
    
    def __init__(self,doc):
        self._reader      = Sax2.Reader()
        self._doc         = self._reader.fromStream( StringIO.StringIO(doc) )
        # For normalizing white space and new lines
        self._multipleWhiteSpace = re.compile('\s\s+',re.U) # multiple occurence of white space char
        self._leadingWhiteSpace  = re.compile('^\s',re.U)   # leading white space
        self._trailingWhiteSpace = re.compile('\s$',re.U)   # trailing white space
        # For pretty print
        self._recursionDepth = 0
        self._indentUnit     = '  '
        # For selecting
        self._excludedContexts    = set()
        self._excludedAppsWithI2O = set()
    
    def normalizeWhiteSpace(self, string):
        """Shrink multiple white space and remove leading and trailing white space"""
        normalized = self._multipleWhiteSpace.sub( ' ', string )
        normalized = self._leadingWhiteSpace.sub( '', normalized )
        normalized = self._trailingWhiteSpace.sub( '', normalized )
        return normalized

    def dropElement(self,node):
        """Determine whether or not to exclude this element (and its descendants) from the new congiguration."""
        if node in self._excludedContexts:
            return True
        if node.tagName == 'i2o:target':
            for app in self._excludedAppsWithI2O:
                if node.getAttribute('class') == app.getAttribute('class') and node.getAttribute('instance') == app.getAttribute('instance'):
                    return True
        return False
            
    def pureTextContent(self,element):
        """True if element has only text content"""
        for c in element.childNodes:
            if c.nodeType != Node.TEXT_NODE:
                return False
        return True

    def reconstructRecursively(self,node,pretty=True):
        """Reconstruct the article from the DOM tree, omitting elements to be excluded"""
        result = u''
        if node.nodeType == Node.DOCUMENT_NODE:
            for c in node.childNodes:
                result += self.reconstructRecursively(c,pretty)
        elif node.nodeType == Node.DOCUMENT_TYPE_NODE:
            pass
        elif node.nodeType == Node.PROCESSING_INSTRUCTION_NODE:
            if pretty:
                result += self._recursionDepth * self._indentUnit + '<?' + node.nodeName + ' ' + node.nodeValue + '?>\n'
            else:
                result += '<?' + node.nodeName + ' ' + node.nodeValue + '?>'
            return result
        elif node.nodeType == Node.COMMENT_NODE:
            if pretty:
                result += self._recursionDepth * self._indentUnit + '<!--' + node.nodeValue + '-->\n'
            else:
                result += '<!--' + node.nodeValue + '-->'
            return result
        elif node.nodeType == Node.ELEMENT_NODE:
            #
            # Is this node (and its descendants) to be displayed?
            #
            if self.dropElement( node ):
                return result
            #
            # start tag:
            #
            as = u''
            if node.attributes:
                for a in node.attributes:
                    as += ' '+a.name+'="'+a.value+'"'
            if node.nodeType <> Node.TEXT_NODE:
                if pretty:
                    result += self._recursionDepth * self._indentUnit
                    result += '<'+node.nodeName+as+'>'
                    if not self.pureTextContent( node ):
                        result += '\n'
                else:
                    result += '<'+node.nodeName+as+'>'
            #
            # child elements:
            #
            self._recursionDepth += 1
            for c in node.childNodes:
                if c.nodeType == Node.TEXT_NODE:
                    text = self.normalizeWhiteSpace( c.data )
                    if len(text.encode('UTF-8')):
                        if pretty:
                            if not self.pureTextContent( node ):
                                result += self._recursionDepth * self._indentUnit
                        result += text
                else:
                    result += self.reconstructRecursively(c,pretty)
            self._recursionDepth -= 1
            #
            # end tag:
            #
            if node.nodeType <> Node.TEXT_NODE:
                if pretty:
                    if not self.pureTextContent( node ):
                        result += self._recursionDepth * self._indentUnit
                    result += '</'+node.nodeName+'>' + '\n'
                else:
                    result += '</'+node.nodeName+'>'
        return result
    
    def printAll(self):
        """Debug print to check the recursive reconstruction of XML from DOM."""
        #ext.PrettyPrint(self._doc)
        print "<?xml version='1.0'?>"
        print self.reconstructRecursively(self._doc).encode('UTF-8')

    def getContextOf(self, hardware):
        """Find out which context this element is in."""
        elem = hardware
        while elem.parentNode:
            if elem.nodeName == 'xc:Context':
                return elem
            elem = elem.parentNode
            
    def collectExcludedAppsWithI2O(self):
        """Find all the applications using I2O that are in the contexts to be excluded."""
        for c in self._excludedContexts:
            for app in c.getElementsByTagName('xc:Application'):
                if app.getAttribute('class') in [ 'EmuRUI', 'RU', 'BU', 'EmuFU' ]:
                    self._excludedAppsWithI2O.add( app )

    def collectExcludedContexts(self, hardwareIn, hardwareOut):
        """Find all the contexts to be excluded, based on the name of the hardware whose data they handle."""
        allReaderContexts  = set()
        keepContexts = set()
        dropContexts = set()
        # all contexts
        for c in self._doc.getElementsByTagName('xc:Context'):
            if len( c.getElementsByTagName('hardwareMnemonic') ) > 0:
                allReaderContexts.add( c )
        # contexts to keep or drop
        for cn in self._doc.getElementsByTagName('hardwareMnemonic'):
            for c in cn.childNodes:
                if c.nodeType == Node.TEXT_NODE:
                    txt = self.normalizeWhiteSpace( c.data ).lower()
                    if   txt in hardwareIn:
                        keepContexts.add( self.getContextOf( cn ) )
                    elif txt in hardwareOut:
                        dropContexts.add( self.getContextOf( cn ) )
        #print 'allReaderContexts',allReaderContexts
        #print 'keepContexts',keepContexts
        #print 'dropContexts',dropContexts
        if len( hardwareIn ) == 0 and len( hardwareOut ) == 0:
            pass
        if len( hardwareIn ) > 0 and len( hardwareOut ) > 0:
            pass
        elif len( hardwareIn ) > 0:
            self._excludedContexts = allReaderContexts.difference( keepContexts )
        elif len( hardwareOut ) > 0:
            self._excludedContexts = dropContexts
        print 'Excluding:'
        for ec in self._excludedContexts:
            m = re.match('(http://)(.*:[0-9]*$)',ec.getAttribute('url'))
            print (30-len(m.group(2)))*' ',m.group(2)


    def cull(self, hardwareIn, hardwareOut):
        """Create and return the new configuration XML containing the requested hardware only."""
        self.collectExcludedContexts(hardwareIn, hardwareOut)
        self.collectExcludedAppsWithI2O()
        return self.reconstructRecursively(self._doc).encode('UTF-8')

def printHelp():
    print """
emuCuller removes hardware from the complete local EmuDAQ farm.

    Usage:
        emuCuller [-c complete_config] [-n new_config] [ -k hardware_to_keep | -r hardware_to_remove ] [-h]

    Options:
        -c    Complete configuration file's name. Default is 'EmuDAQ_SliceTest_Complete.xml'.
        -n    New configuration file's name. Default is 'EmuDAQ_SliceTest.xml'.
        -k    Comma-separated list of hardware names to keep in the configuration. (All others will be removed.)
              Names are case-insensitive. Default is empty list.
        -r    Comma-separated list of hardware names to remove from the complete configuration.
              Names are case-insensitive. Default is empty list.
        -h    Print this help.

    Examples:
        emuCuller -n EmuDAQ_ME1_only.xml -k me1a,me1b
        emuCuller -n EmuDAQ_ME3_out.xml -r Me3
        emuCuller -n Copy_of_EmuDAQ_SliceTest_Complete.xml 
"""

if __name__ == "__main__":
    
    # user is clueless
    if len(sys.argv) == 1:
        printHelp()
        sys.exit(0)

    # default arguments
    completeConfigFileName = 'EmuDAQ_SliceTest_Complete.xml'
    newConfigFileName      = "EmuDAQ_SliceTest.xml"
    hardwareIn  = []
    hardwareOut = []

    # user's command line options
    for i in range(1,len(sys.argv)):
        if sys.argv[i] == '-c':
            completeConfigFileName = sys.argv[i+1]
        elif sys.argv[i] == '-n':
            newConfigFileName = sys.argv[i+1]
        elif sys.argv[i] == '-k':
            if i+1 < len(sys.argv):
                hardwareIn = re.split(',',sys.argv[i+1].lower())
        elif sys.argv[i] == '-r':
            if i+1 < len(sys.argv):
                hardwareOut = re.split(',',sys.argv[i+1].lower())
        elif sys.argv[i] == '-h':
            printHelp()
            sys.exit(0)

    # read in the complete configuration
    try:
        completeConfigFile = open(completeConfigFileName,'r')
    except:
        print '***** Error opening',completeConfigFileName
        sys.exit(1)
    completeConfigXML = completeConfigFile.read()

    # sort them out
    culler = emuCuller( completeConfigXML )
    #culler.printAll()
    user = 'UNKNOWN_USER'
    host = 'UNKNOWN_HOST'
    pwd  = 'UNKNOWN_DIR'
    time = str(datetime.datetime.utcnow())
    if 'USER' in os.environ:
        user = os.environ['USER']
    if 'HOST' in os.environ:
        host = os.environ['HOST']
    if 'PWD' in os.environ:
        pwd = os.environ['PWD']
    newConfigXML  = "<?xml version='1.0'?>\n"
    newConfigXML += "<!-- Generated by emuCuller from "+user+'@'+host+':'+pwd+'/'+completeConfigFileName+' at '+time+" UTC -->\n"
    newConfigXML += culler.cull( hardwareIn, hardwareOut )

    # save the new configuration
    try:
        newConfigFile = open(newConfigFileName,'w')
    except:
        print '***** Error opening',newConfigFileName
        sys.exit(1)
    try:
        newConfigFile.write( newConfigXML )
    except:
        print '***** Error writing',newConfigFileName
        sys.exit(1)
    print '\nWrote',newConfigFileName,'\n'
