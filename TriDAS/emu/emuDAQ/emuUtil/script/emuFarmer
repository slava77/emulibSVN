#!/usr/bin/python2.4
# -*- coding: utf-8 -*-

from xml.dom.ext.reader import Sax2
from xml.dom import Node
import StringIO
import sys
import os
import re
import popen2
import httplib
import threading
import logging
import logging.handlers

# for merging
import datetime
from Ft.Xml.Xslt import Processor
from Ft.Xml import InputSource
#from Ft.Lib.Uri import OsPathToUri

#################
class Emu_Farmer:
#################
    
    def __init__( self, configFileName, user, targets, xdaq_root, logLevel, dirForMerged ):
        self._configFileName = configFileName
        # The remote user
        self._user                = user
        self._target              = targets
        self._xdaq_root           = xdaq_root
        self._logLevel            = logLevel
        self._mergedConfigFileDir = dirForMerged

        # The content of the config XML file
        self._configString = None
        # The DOM document created from the config XML file
        self._configDoc = None

        # The local name and URL of the merged config file
        self._mergedConfigFileName = ''
        self._mergedConfigFileURL  = ''
        # The DOM document created from the merged config XML file
        self._mergedConfigDoc = None
        
        # The XML reader
        self._reader = Sax2.Reader()
        

        # Dict of all command lines
        self._commandLines = {} # { context : commandLine }
        # Dict of command lines to issue
        self._relevantCommandLines = {} # { context : commandLine }

        # Dict of targets
        self._targets = { 'EmuRUI'             : 'daq',
                          'RU'                 : 'daq',
                          'BU'                 : 'daq',
                          'EVM'                : 'daq',
                          'EmuTA'              : 'daq',
                          'EmuFU'              : 'daq',
                          'EmuDAQManager'      : 'man',
                          'EmuPeripheralCrate' : 'pc' ,
                          'LTCControl'         : 'ltc',
                          'EmuFEDCrate'        : 'fed',
                          'EmuFCrateHyperDAQ'  : 'fed',
                          'EmuMonitor'         : 'dqm',
                          'CSCSupervisor'      : 'sv'   }

        # Dict of context sets grouped by target (context='host:port')
        self._contexts = { 'daq' : set(),
                           'man' : set(),
                           'fed' : set(),
                           'pc'  : set(),
                           'ltc' : set(),
                           'sv'  : set(),
                           'dqm' : set(),
                           'all' : set() }

        # List of ssh threads
        self._sshThreads = []

        self._date_time = self.getDateAndTime()
        
        self.validateOptions()
        print self.listOptions()
        fileLog.debug( self.listOptions() )

        self.getConfigFile()
        self.mergeConfigFiles()

    def act( self, action ):
        self._action = action

        if self._action == 'reload':
            self.createReloadCommandLines()
            for host,cmnd in self._commandLines.iteritems():
                prettyContext = (20-len(host))*' '+'[34m'+host+'[0m'+20*' '
                #print prettyContext
                #print host, cmnd
                sshThread = AsyncSSH( prettyContext, cmnd, True )
                sshThread.setName( host )
                self._sshThreads.append( sshThread )
                sshThread.start()
        else:
            self.createCommandLines()
            self.pickRelevantCommandLines()
            if self._action == 'status':
                print '----------------------- status (S: sleeping  |  R: running  |  *nothing*: no process found):'
            if self._action == 'debug':
                print "----------------------- remote processes' standard output (see ./emuFarmer.log for details):"
            for ctxt,cmnd in self._relevantCommandLines.iteritems():
                #print ctxt,'\n',commands.getoutput(cmnd) # doesn't stop when starting xdaq as it wants to read stdout...
                tgts = '  ( '+self.listTargets(ctxt)+')'
                prettyContext = (20-len(ctxt))*' '+'[34m'+ctxt+'[0m'+tgts+(20-len(tgts))*' '
                # gathering status info one-by-one is too slow; do it in parallel
                if self._action in [ 'status', 'debug' ]:
                    sshThread = AsyncSSH( prettyContext, cmnd )
                    sshThread.setName( ctxt )
                    self._sshThreads.append( sshThread )
                    sshThread.start()
                elif self._action == 'start':
                    f = popen2.popen4(cmnd)
                    fileLog.debug(prettyContext+'starting:     '+cmnd)
                    screenLog.info(prettyContext+'starting')
                elif self._action == 'stop':
                    f = popen2.popen4(cmnd)
                    fileLog.debug(prettyContext+'stopping:     '+cmnd)
                    screenLog.info(prettyContext+'stopping')
        # We must wait for the threads to finish,
        # otherwise the main thread may exit and shut down the logger before
        # the child threads have had a chance to write to the log file.
        self.waitForThreads()

    def listTargets( self, context ):
        tgtList = ''
        for tgtGroupName,tgtContexts in self._contexts.iteritems():
            if tgtGroupName != 'all' and context in tgtContexts:
                tgtList += tgtGroupName+' '
        return tgtList
    
    def validateOptions( self ):
        if self._logLevel not in ['DEBUG','INFO','WARN','ERROR','FATAL']:
            print '***** Error:',self._logLevel,'is not a valid log level. Use [DEBUG|INFO|WARN|ERROR|FATAL]'
            print '      Type emuFarmer -h for help.'
            sys.exit(1)
        for g in re.split('[+\-]',self._target):
            if g not in self._contexts and g.find(':') <= 0:
                print '***** Error:',g,'is not a valid target group or context. Use',self._contexts.keys(),' and/or \'host:port\''
                print '      Type emuFarmer -h for help.'
                sys.exit(1)
        if len(self._xdaq_root) == 0:
            print '***** Error: XDAQ_ROOT for remote hosts not specified. Use -X <xdaq_root>'
            print '      Type emuFarmer -h for help.'
            sys.exit(1)

    def listOptions( self ):
        options  = '\n'
        options += '        Config file name/URL  :\t' + self._configFileName      + '\n'
        options += '        Dir for merged config :\t' + self._mergedConfigFileDir + '\n'
        options += '        Target groups         :\t' + self._target              + '\n'
        options += '        Log level             :\t' + self._logLevel            + '\n'
        options += '        User                  :\t' + self._user                + '\n'
        options += '        XDAQ_ROOT             :\t' + self._xdaq_root           + '\n'
        return options

    def getConfigFile( self ):
        m = re.match( 'http://(.+?)/', self._configFileName )
        if m:
            configFileHost = m.group(1)
            conn           = httplib.HTTPConnection( configFileHost )
            conn.request( "GET", self._configFileName )
            response = conn.getresponse()
            if response.status <> httplib.OK:
                print 'Failed to get ',self._configFileName, '\nReason: ',response.reason
                sys.exit(1)
            self._configString = response.read()
            self._configDoc    = self._reader.fromStream( StringIO.StringIO( self._configString ) )
            return
        m = re.match( 'file://(.+)', self._configFileName )
        if m:
            configFilePath     = m.group(1)
            configFile         = open( configFilePath, 'r' )
            self._configString = configFile.read()
            self._configDoc    = self._reader.fromStream( configFilePath )
            return
        configFile         = open( self._configFileName, 'r' )
        self._configString = configFile.read()
        self._configDoc    = self._reader.fromStream( self._configFileName )

    def mergeConfigFiles( self ):
        contexts = self._configDoc.getElementsByTagName('xc:Context')
        filelist = self._configDoc.getElementsByTagName('EmuConfigFileList')
        if len(contexts) != 0:
            # this already seems to be the config file itself; no need to do anything
            self._mergedConfigFileName = self._configFileName
            self._mergedConfigFileURL  = self._configFileName
            self._mergedConfigDoc      = self._configDoc
            print '\nUsing[32m', self._mergedConfigFileURL,'[0m\n'
            return
        elif len(filelist) != 0:
            self.nameMergedConfigFile()
            merger                = Emu_Merger( self._configString )
            mergedConfigString    = merger.getMergedConfig()
            self._mergedConfigDoc = self._reader.fromStream( StringIO.StringIO( mergedConfigString ) )
            print '\nWriting', self._mergedConfigFileName,'\n'
            mergedFile = open( self._mergedConfigFileName, 'w' )
            mergedFile.write( mergedConfigString )
            mergedFile.close()
            self.depositMergedConfigFile()
            print 'Using  [35m', self._mergedConfigFileURL,'[0m\n'
            return
        else:
            print '***** Error: Could find neither XDAQ executive contexts nor file list in',self._configFileName
            print '      Type emuFarmer -h for help.'
            sys.exit(1)

    def getDateAndTime( self ):
        dt = datetime.datetime.utcnow()
        date_time  = str( dt.year   )
        date_time += str( dt.month  ).zfill(2)
        date_time += str( dt.day    ).zfill(2)
        date_time += '_'
        date_time += str( dt.hour   ).zfill(2)
        date_time += str( dt.minute ).zfill(2)
        date_time += str( dt.second ).zfill(2)
        return date_time

    def nameMergedConfigFile( self ):
        self._mergedConfigFileName += 'EmuConfig_Merged_' + self._date_time + '_UTC.xml'
        m = re.match('(.*)@(.*):(.*)',self._mergedConfigFileDir)
        user = m.group(1)
        host = m.group(2)
        cdir = m.group(3)
        if m == None:
            print '***** Error:',self._mergedConfigFileDir,'is not a valid destination directory for the configuration file.'
            print '      Type emuFarmer -h for help.'
            sys.exit(1)
        self._mergedConfigFileURL += 'http://' + host + '/' + user + '/' + cdir + '/' + self._mergedConfigFileName

    def depositMergedConfigFile( self ):
        mergedConfigFilePath = self._mergedConfigFileDir + '/' + self._mergedConfigFileName
        print 'Copying merged configuration file to', mergedConfigFilePath, '\n'
        # Some scp versions don't support option -2
        scpCommand = 'scp -2 '+ self._mergedConfigFileName +' '+ self._mergedConfigFileDir + ' || { echo -n "Trying copying without option -2 ..."; scp '+ self._mergedConfigFileName +' '+ self._mergedConfigFileDir +' && echo " OK."; }'
        fileLog.debug( scpCommand )
        f = popen2.popen4( scpCommand )
        scpStdOut = f[0].read()
        print scpStdOut
        fileLog.debug( scpStdOut )
        
    def escapeRegexpSpecialChar( self, s ):
        ss = re.sub('\.','\.',s )
        ss = re.sub('\+','\+',ss)
        ss = re.sub('\/','\/',ss)
        return ss

    def createReloadCommandLines( self ):
        contexts = self._mergedConfigDoc.getElementsByTagName('xc:Context')
        for context in contexts:
            url = context.getAttributeNode('url').firstChild.data
            m = re.match('(http://)(.*):',url)
            host = m.group(2)
            remoteCommand = '"(export XDAQ_ROOT='+self._xdaq_root+' && \$XDAQ_ROOT/emu/emuDAQ/drivers/bigphysarea_xxxx/bin/emuLoadDDUs)"'
            commandLine = 'ssh -2 -f '+self._user+'@'+host+' '+remoteCommand

            # add this command to the self._commandLines only if this host runs EmuRUI(s)
            self._contexts['all'].add(host)
            apps = context.getElementsByTagName('xc:Application')
            for app in apps:
                klass = app.getAttributeNode('class').firstChild.data
                if klass=='EmuRUI':
                    self._commandLines[host] = commandLine


    def createCommandLines( self ):
        contexts = self._mergedConfigDoc.getElementsByTagName('xc:Context')
        for context in contexts:
            url = context.getAttributeNode('url').firstChild.data
            m = re.match('(http://)(.*):([0-9]*$)',url)
            host = m.group(2)
            port = m.group(3)

            remoteLogFile = 'emuFarmer_UTC_'+self._date_time+'_port_'+port+'.log'

            if self._action == 'start':
                #remoteCommand = '"(export XDAQ_ROOT='+self._xdaq_root+' && \$XDAQ_ROOT/daq/xdaq/bin/linux/x86/xdaq.sh -h '+host+' -p '+port+' -l '+self._logLevel+' -c '+self._mergedConfigFileURL+' &> /dev/null &)"'
                # Redirect std error and output to a remoteLogFile.
                # (When starting, we cannot wait for the std output of the ssh process
                # as the remote shell won't exit unless xdaq crashes.)
                remoteCommand = '"(export XDAQ_ROOT='+self._xdaq_root+' && \$XDAQ_ROOT/daq/xdaq/bin/linux/x86/xdaq.sh -h '+host+' -p '+port+' -l '+self._logLevel+' -c '+self._mergedConfigFileURL+' &> '+remoteLogFile+' &)"'
            elif self._action == 'stop':
                remoteCommand = "\"ps -e j | gawk '!/gawk/ && /xdaq\.exe/ && /-h[ ]+"+self.escapeRegexpSpecialChar(host)+"/ && /-p[ ]+"+port+"/ { print \$2 }' | xargs -r kill -9\""
            elif self._action == 'status':
                #remoteCommand = "\"ps -e j | gawk '!/gawk/ && /xdaq\.exe/ && /-h[ ]+"+self.escapeRegexpSpecialChar(host)+"/ && /-p[ ]+"+port+"/ { print \$7 }'\""
                #remoteCommand = "\"ps -eo stat,pid,euser,lstart,command | gawk '!/gawk/ && /xdaq\.exe/ && /-h[ ]+"+self.escapeRegexpSpecialChar(host)+"/ && /-p[ ]+"+port+"/ { printf(\\\"%3s  %5d   %10s   %3s %3s %2d %s\\\",\$1,\$2,\$3,\$4,\$5,\$6,\$7) }'\""
                remoteCommand = "\"ps -eo stat,pid,euser,lstart,command | gawk '!/gawk/ && /xdaq\.exe/ && /-h[ ]+"+self.escapeRegexpSpecialChar(host)+"/ && /-p[ ]+"+port+"/ { print \$1,\\\"  ( process\\\",\$2,\\\"\tstarted by\\\",\$3,\\\"at\\\",\$4,\$5,\$6,\$7,\\\")\\\"}'\""
            elif self._action == 'debug':
                # Dump the remoteLogFile (the redirected std err/out of xdaq)
                remoteCommand = "\"cat "+remoteLogFile+"\""

            commandLine = 'ssh -2 -f '+self._user+'@'+host+' '+remoteCommand
            hostAndPort = host+':'+port
            self._commandLines[hostAndPort] = commandLine
            
            # put this command in the appropriate target set(s)
            self._contexts['all'].add(hostAndPort)
            apps = context.getElementsByTagName('xc:Application')
            for app in apps:
                klass = app.getAttributeNode('class').firstChild.data
                if self._targets.has_key(klass):
                    target = self._targets[klass]
                    self._contexts[target].add(hostAndPort)
                    #print hostAndPort,' added to ',target

        #print '\nGrouping of contexts:'
        #for tgt,ctxt in self._contexts.iteritems():
        #    print tgt
        #    for c in ctxt:
        #        print '     ',c
        #
        #print '\nAll command lines'
        #for ctxt,cmnd in self._commandLines.iteritems():
        #    print ctxt,'\n        ',cmnd
        
    def pickRelevantCommandLines( self ):
        groupToAdd  = set()
        groupToOmit = set()
        # parse the string of specified targets
        target = self._target+' ' # add space for safety
        sign = '+'
        t = ''
        for i in range(len(target)):
            if target[i] == '+' or target[i] == '-':
                if len(t) > 0:
                    if self._contexts.has_key(t):
                        if sign == '+': groupToAdd  = groupToAdd  | self._contexts[t]
                        else          : groupToOmit = groupToOmit | self._contexts[t]
                    elif t.find(':') > 0:
                        if sign == '+': groupToAdd.add( t )
                        else          : groupToOmit.add( t )
                    else:
                        print '***** Error: ',t,' is not a recognized target group or context (host:port)'
                sign = self._target[i]
                t = ''
            elif i == len(self._target):
                if len(t) > 0:
                    if self._contexts.has_key(t):
                        if sign == '+': groupToAdd  = groupToAdd  | self._contexts[t]
                        else          : groupToOmit = groupToOmit | self._contexts[t]
                    elif t.find(':') > 0:
                        if sign == '+': groupToAdd.add( t )
                        else          : groupToOmit.add( t )
                    else:
                        print '***** Error: ',t,' is not a recognized target group or context (host:port)'
                t = ''
            else:
                t += self._target[i]
            
        relevantContexts = groupToAdd - groupToOmit
        #print 'add\n',groupToAdd
        #print 'omit\n',groupToOmit
        #print 'add-omit\n',relevantContexts
        if len( relevantContexts ) == 0:
            print self._target,' corresponds to no context in ',self._mergedConfigFileName
            print '      Type emuFarmer -h for help.'
            sys.exit(1)
        for rctxt in relevantContexts:
            self._relevantCommandLines[rctxt] = self._commandLines[rctxt]

        
    def waitForThreads(self):
        allFinished = False
        while not allFinished:
            allFinished = True
            for thread in farmer._sshThreads:
                allFinished &= not thread.isAlive()
                #print i,thread.getName(), thread.isAlive()
        
#################################
class AsyncSSH(threading.Thread):
#################################

    def __init__(self, context, command, printAll=False):
        threading.Thread.__init__(self)        
        self._context  = context
        self._command  = command
        self._printAll = printAll
        
    def run(self):
        report = ''
        f = popen2.popen4(self._command)
        status = f[0].read() # this blocks when xdaq is being started
        if self._printAll:
            fileLog.debug(self._context+status)
            screenLog.info(self._context+status)
        else:
            st = re.split('\n',status)
            if len(st) >= 2:
                fileLog.debug(self._context+status)
                # print the last-but-one line (the last one is empty)
                screenLog.info(self._context+st[-2])
            else:
                fileLog.debug(self._context+status)
                # print the only line (must be empty...)
                screenLog.info(self._context+st[-1])
        f[0].close()

#################
class Emu_Merger:
#################
    
    def __init__( self, configListString ):
        # the URI in the next call is nothing but an id
        self._source    = InputSource.DefaultFactory.fromString( configListString, "http://emudaq/config/EmuConfig.xml")
        self._processor = Processor.Processor()
        TRANSFORM       = """<?xml version="1.0" encoding="UTF-8"?>

<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:i2o="http://xdaq.web.cern.ch/xdaq/xsd/2004/I2OConfiguration-30" xmlns:xc="http://xdaq.web.cern.ch/xdaq/xsd/2004/XMLConfiguration-30" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xp="http://xdaq.web.cern.ch/xdaq/xsd/2005/XMLProfile-10" xmlns:fn="http://www.w3.org/2005/02/xpath-functions">

  <xsl:output method="xml" indent="yes"/> 

  <xsl:template match="EmuConfigFileList">
    <xsl:processing-instruction name="xml-stylesheet">type="text/xsl" href="EmuDAQConfig.xsl"</xsl:processing-instruction> 
    <xc:Partition xmlns:soapenc="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xc="http://xdaq.web.cern.ch/xdaq/xsd/2004/XMLConfiguration-30" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
      <xsl:call-template name="protocol"/>
      <xsl:call-template name="contexts"/>
    </xc:Partition>
  </xsl:template>

  <xsl:template name="protocol">
    <!-- merge i2o:protocol elements from all files into one i2o:protocol element -->
    <i2o:protocol xmlns:i2o="http://xdaq.web.cern.ch/xdaq/xsd/2004/I2OConfiguration-30">
    <xsl:for-each select="uri">
      <xsl:variable name="URI"><xsl:value-of select="."/></xsl:variable>
      <xsl:for-each select="document($URI)/xc:Partition/i2o:protocol/i2o:target">
	<xsl:copy-of select="."/>
      </xsl:for-each>
    </xsl:for-each>      
    </i2o:protocol>
  </xsl:template>

  <xsl:template name="contexts">
    <!-- collect all xc:Context elements from all files -->
    <xsl:for-each select="uri">
      <xsl:variable name="URI"><xsl:value-of select="."/></xsl:variable>
      <xsl:for-each select="document($URI)/xc:Partition/xc:Context">
	<xsl:copy-of select="."/>
      </xsl:for-each>
    </xsl:for-each>      
  </xsl:template>

</xsl:stylesheet>
"""
        # the URI in the next call is nothing but an id
        transform = InputSource.DefaultFactory.fromString(TRANSFORM,
                                                          "http://emudaq/config/EmuConfigAssembler.xsl")
        self._processor.appendStylesheet( transform )
      
    def getMergedConfig( self ):
        return self._processor.run( self._source )

def printHelp():
    print """
emuFarmer reloads drivers or launches/kills XDAQ executives specified in a XDAQ XML configuration file.

    Usage:
        emuFarmer -c config_file [-u user] [-a action] [-t target_group] [-l log_level] [-X xdaq_root] [-d merged_config_destination] [-h]

        It logs to the standard error and $PWD/emuFarmer.log


    Options:
        -c    Configuration file's absolute path or URL. (A "mandatory option".)
              Two configuration file formats are supported:
                 1) Standard XDAQ configuration.
                    The remote processes will be instructed to take this file from the same URL.
                 2) A list of standard XDAQ configuration files, e.g.:
                        <?xml version="1.0" encoding="UTF-8"?>
                        <EmuConfigFileList>
                          <uri>http://emudaq/EmuDAQ/xml/EmuDAQ_SliceTest.xml</uri>
                          <uri>file:///home/slicedev/DAQKit/TriDAS/emu/cscSV/test/config.xml</uri>
                        </EmuConfigFileList>
                    The listed files will be merged into
                    user@host:directory/EmuConfig_Merged_YYYYMMDD_hhmmss_UTC.xml
                    and assumed to be accessible at
                    http://host/user/directory/EmuConfig_Merged_YYYYMMDD_hhmmss_UTC.xml
		    user@host:directory can be specified with the -d option.
        -d    Destination directory for the merged configuration file.
              Format: user@host:directory
              The remote processes will be instructed to take the merged configuration from
              http://host/user/directory
              Default is user@emudaq:config (See option -u for 'user'.)
        -a    Action [status|start|stop|restart|reload] to take. Default is 'status'.
              'status' prints the process state code reported by 'ps'. (See the ps man pages.)
              'reload' will (re)load the drivers in all nodes running EmuRUIs. Options -l and -t
              have no effect in 'reload'.
        -t    Targeted executives (host:port) and/or group(s) of targeted executives.
              Group name   Executives running
               daq           DAQ column (any of EmuRUI, RU, BU, EVM, EmuTA or EmuFU)
               ltc           LTCControl
               man           EmuDAQManager
               fed           EmuFEDCrate or EmuFCrateHyperDAQ
               pc            EmuPeripheralCrate
               sv            CSCSupervisor
               dqm           EmuMonitor
               all           any application
              E.g., man+daq will select all executives running DAQManager or DAQ column applications,
              all-ltc will select all executives except the one running LTCControl,
              daq-emudaq01:40201 will select all executives running DAQ column applications except emudaq01:40201.
              Default is 'daq+man+sv', i.e., the DAQ column, the DAQManager and the CSCSupervisor.
        -u    User to run the executives on the remote hosts. Default is $USER of the shell where emuFarmer is run.
        -X    XDAQ_ROOT on the remote hosts. Default is $XDAQ_ROOT of the shell where emuFarmer is run.
        -l    XDAQ executives' log level. Default is WARN.
        -h    Print this help.


    Example:
        emuFarmer -l INFO -c http://emudaq/cscdaq/config/EmuDAQ/EmuDAQ_SliceTest.xml -a start
    """

if __name__ == "__main__":

    # user is clueless
    if len(sys.argv) == 1:
        printHelp()
        sys.exit(0)

    # default arguments
    configFileName =  None
    action         = 'status'
    targets        = 'daq+man+sv'
    logLevel       = 'WARN'
    user           = ''
    xdaq_root      = ''
    dirForMerged   =  None
    
    # user's command line options
    for i in range(1,len(sys.argv)):
        if sys.argv[i] == '-c':
            configFileName = sys.argv[i+1]
        elif sys.argv[i] == '-a':
            action = sys.argv[i+1]
        elif sys.argv[i] == '-t':
            targets = sys.argv[i+1]
        elif sys.argv[i] == '-l':
            logLevel = sys.argv[i+1]
        elif sys.argv[i] == '-u':
            user = sys.argv[i+1]
        elif sys.argv[i] == '-X':
            xdaq_root = sys.argv[i+1]
        elif sys.argv[i] == '-d':
            dirForMerged = sys.argv[i+1]
        elif sys.argv[i] == '-h':
            printHelp()
            sys.exit(0)

    # user must be known
    if user == '' and 'USER' not in os.environ:
        print '***** Error: No user specified. Please use the "-u <user>" option.'
        print '      Type emuFarmer -h for help.'
        sys.exit(1)
    if user == '':
        user = os.environ['USER']

    # now we can set the default destination directory for the merged configuration file
    if dirForMerged == None:
        dirForMerged = user+'@emudaq:config'

    # XDAQ_ROOT must be known
    if xdaq_root == '' and 'XDAQ_ROOT' not in os.environ:
        print '***** Error: No XDAQ_ROOT specified or set. Please use the "-X <xdaq_root>" option.'
        print '      Type emuFarmer -h for help.'
        sys.exit(1)
    if xdaq_root == '' and 'XDAQ_ROOT' in os.environ:
        xdaq_root  = os.environ['XDAQ_ROOT']

    # we must have a config file
    if configFileName == None:
        print '***** Error: No configuration file specified. Please use the "-c <configFile>" option.'
        print '      Type emuFarmer -h for help.'
        sys.exit(1)

    # we must have a destination directory for the merged configuration file
    if dirForMerged == None:
        print '***** Error: No destination directory specified for the merged configuration file.'
        print '      Please use the "-d <user@host:dir>" option.'
        print '      Type emuFarmer -h for help.'
        sys.exit(1)

    # can we do that?
    if action not in ['status','start','stop','restart','reload']:
        print '***** Error:',action,'is not a recognized action. Use [status|start|stop|restart|reload]'
        print '      Type emuFarmer -h for help.'
        sys.exit(1)

    # set up logger to screen and file too
    logging.basicConfig(level=logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s %(message)s')

    fileLogHandler = logging.handlers.RotatingFileHandler('emuFarmer.log','a',100000,2)
    fileLogHandler.setFormatter(formatter)
    fileLogHandler.setLevel(logging.DEBUG)
    fileLog = logging.getLogger('fileLog')
    fileLog.addHandler(fileLogHandler)
    fileLog.propagate = False
    
    screenLogHandler = logging.StreamHandler()
    screenLogHandler.setFormatter(formatter)
    screenLogHandler.setLevel(logging.INFO)
    screenLog = logging.getLogger('screenLog')
    screenLog.addHandler(screenLogHandler)
    screenLog.propagate = False

    # let's roll
    farmer = Emu_Farmer( configFileName, user, targets, xdaq_root, logLevel, dirForMerged )
    if action == 'reload':
        farmer.act( action )
        sys.exit(0)
    farmer.act( 'status' )
    if action == 'status': sys.exit(0)
    if re.match('y',raw_input('----------------------- '+action+'? [y|n] ')):
        if action == 'restart':
            farmer.act( 'stop' )
            farmer.act( 'status' )
            print ''
            farmer.act( 'start' )
            farmer.act( 'status' )
        else:
            farmer.act( action )
            farmer.act( 'status' )
        if action in [ 'start', 'restart' ]:
            farmer.act( 'debug' )
