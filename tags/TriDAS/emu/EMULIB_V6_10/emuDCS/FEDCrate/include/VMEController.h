/*****************************************************************************\
* $Id: VMEController.h,v 3.16 2009/01/29 15:31:23 paste Exp $
*
* $Log: VMEController.h,v $
* Revision 3.16  2009/01/29 15:31:23  paste
* Massive update to properly throw and catch exceptions, improve documentation, deploy new namespaces, and prepare for Sentinel messaging.
*
* Revision 3.15  2008/10/01 14:10:03  paste
* Fixed phantom reset bug in IRQ threads and shifted IRQ handling functions to VMEController object.
*
* Revision 3.14  2008/09/29 08:36:26  paste
* Removed references to extinct JTAGDevice.h
*
* Revision 3.13  2008/09/24 18:38:38  paste
* Completed new VME communication protocols.
*
* Revision 3.12  2008/09/03 17:52:58  paste
* Rebuilt the VMEController and VMEModule classes from the EMULIB_V6_4 tagged versions and backported important changes in attempt to fix "high-bits" bug.
*
* Revision 3.11  2008/08/19 14:51:02  paste
* Update to make VMEModules more independent of VMEControllers.
*
* Revision 3.10  2008/08/15 16:14:50  paste
* Fixed threads (hopefully).
*
* Revision 3.9  2008/08/15 08:35:51  paste
* Massive update to finalize namespace introduction and to clean up stale log messages in the code.
*
*
\*****************************************************************************/
#ifndef __VMECONTROLLER_H__
#define __VMECONTROLLER_H__

#include <pthread.h> // for mutexes

#include "JTAG_constants.h"
#include "FEDException.h"

namespace emu {

	namespace fed {

		class VMEModule;

		/** @class VMEController A class for establishing communication with a CAEN VME controller **/
		class VMEController
		{
		public:

			/** Default constructor.
			*
			*	@param Device the PCI device number.
			*	@param Link the position of the target controller in a daisy chain.
			**/
			VMEController(int Device, int Link)
			throw (CAENException);

			/** Default destructor. **/
			~VMEController();

			/** @returns the device number. **/
			inline int getDevice() {return Device_;}

			/** @returns the link number. **/
			inline int getLink() {return Link_;}

			/** @returns the CAEN BHandle, **/
			inline int32_t getBHandle() { return BHandle_; }
			
			/** Set the IRQ enabled and wait until an interrupt comes through.
			*
			*	@param mSecs the number of milliseconds to wait for an
			*	interrupt before exiting with all clear status.
			*
			*	@returns false if there was an interrupt set, true otherwise.
			**/
			bool waitIRQ(unsigned int mSecs = 5000)
			throw (CAENException);
			
			/** Read the VME IRQ channel
			*
			*	@returns the 16-bits read from the IRQ channel.
			**/
			uint16_t readIRQ()
			throw (CAENException);
			
			/**	I am doing something smart here.  Instead of making the BHandles extern,
			*	I am going to have the original constructor set its own BHanlde to a
			*	crazy value in case of an error.  Thus, if the device is already open, I
			*	will be able to check the BHandle to figure that out, then simply replace
			*	the BHandle with the correct value once I know it.
			**/
			inline void setBHandle(int32_t BHandle) { BHandle_ = BHandle; }

		private:

			/// The device number.  One driver instance controls all the CAEN PCI boards on a machine, so this number chooses to which CAEN board communication will be addressed.
			int Device_;

			/// The daisy-chain link number.  The controllers can be connected in a daisy-chain fashion, with the transmit line of one plugged into the receive line of the next.  This chooses which device in the daisy-chain to address.
			int Link_;

			/// The BHandle.  This is a unique number generated by the driver and used to pick which Device/Link pair a given command addresses.
			int32_t BHandle_;

			/// A mutex to make establishment of a controller and communication to it atomic.
			pthread_mutex_t mutex_;

		};

	}
}

#endif

