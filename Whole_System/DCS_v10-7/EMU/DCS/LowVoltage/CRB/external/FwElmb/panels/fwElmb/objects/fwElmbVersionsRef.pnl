V 10
1
LANG:1 8 (NoName)
PANEL,-1 -1 269 129 N "_3DFace" 1
"$sDpName"
E E E E E 1 -1 -1 0  20 60
""0  1
E "bool pnlGetElmbName(string sDpName,
										string &sElmbName)
{
// Local Variables
// ---------------
	bool bStatus = false;
	
	dyn_string dsTemp;
	
// Executable Code
// ---------------
	// Get the name of the ELMB from the DP
	dsTemp = strsplit(sDpName, fwDevice_HIERARCHY_SEPARATOR);
	
	if (dynlen(dsTemp) > 2) {
		sElmbName = dsTemp[1] + fwDevice_HIERARCHY_SEPARATOR + dsTemp[2] + fwDevice_HIERARCHY_SEPARATOR + dsTemp[3];
		
		// Check this DP exists and that it is of the correct type
		if (dpExists(sElmbName)) {
			if (dpTypeName(sElmbName) == ELMB_TYPE_NAME)
				bStatus = true;
		}
	}

	// Return to calling routine
	return (bStatus);
}

void pnlIntToString(int src, string &str)
{
// Local Variables
// ---------------
	char cTemp;
	
	int i, iTemp;
	
	string sTemp;
	string sChar;
	
	dyn_string dsTemp;
	
// Executable Code
// ---------------
	// Convert decimal value to hex
	sprintf(sTemp, \"%x\", src);

	// Loop through hex 'string', obtaining individual bytes (i.e. pairs of two hex digits)
	for (i = 0; i < strlen(sTemp); i += 2) {
		sChar = substr(sTemp, i, 2);
		dynAppend(dsTemp, sChar);
	} 
	
	// Loop through the 'bytes', converting values to integers, then casting to ASCII characters
	for (i = 1; i <= dynlen(dsTemp); i++) {
		sscanf(dsTemp[i], \"%x\", iTemp);
		
		// Cast to ascii
		cTemp = iTemp;
		dsTemp[i] = cTemp;
	}
	
	// Concatenate each character to create the final string
	for (i = 1; i <= dynlen(dsTemp); i++) 
		str += dsTemp[dynlen(dsTemp) - (i - 1)];

	// Return to calling routine
	return;
}" 0
 2
"CBRef" "1"
"EClose" E
""
DISPLAY_LAYER, 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
LAYER, 0 
1
LANG:1 6 Layer1
2 0
"lblHwVer"
""
1 20 60 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
1 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 22 62 128 78
0 2 0 "0s" 0 0 0 64 0 0  22 62 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 17 Hardware version:
2 1
"lblSwVer"
""
1 20 30 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
2 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 22 32 128 48
0 2 0 "0s" 0 0 0 64 0 0  22 32 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 17 Software version:
30 2
"frmFirmware"
""
1 10 120 E E E 1 E 1 E N "_3DText" E N "_Transparent" E E
 E E
3 0 0 0 0 0
E E E
1
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 10 10 260 120
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 8 Firmware
2 3
"lblDash"
""
1 180 30 E E E 1 E 0 E N "_WindowText" E N "_Transparent" E E
 E E
4 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 182 32 198 48
0 2 0 "0s" 0 0 0 65 0 0  182 32 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 1 -
2 4
"lblSerialNumber"
""
1 20 90 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
5 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 22 92 108 108
0 2 0 "0s" 0 0 0 64 0 0  22 92 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 14 Serial Number:
14 5
"txtSwVer"
""
1 130 30 E E E 1 E 1 E N "_WindowText" E N "_3DFace" E E
 E E
6 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 128 28 182 55
2 "0s" 0 0 0 0 0 -1  E "main()
{
// Local Variables
// ---------------
  string sElmbName;

// Executable Code
// ---------------
  if (pnlGetElmbName($sDpName, sElmbName)) {

    // Connect to the SW version information
    dpConnect(\"cbkSWVersion\", false,
              sElmbName + \".swVersion\");
  }
	
  // Return to calling routine
  return;
}

void cbkSWVersion(string sSWVersionDpe, unsigned uSWVersion)
{
// Local Variables
// ---------------
  bool bSNValid = false;
  bool bSubVersionValid = false;
	
  int iSWVersion;
	
  string sSwVersion;
  string sTemp;

// Executable Code
// ---------------
  pnlIntToString(uSWVersion, sSwVersion);
  txtSwVer.text = sSwVersion;
	
  if (strlen(sSwVersion) == 4) {
    sTemp = substr(sSwVersion, 2, 2);
    iSWVersion = sTemp;
		
    // Check if we expect a serial number to exist (only after MA36)
    if ((substr(sSwVersion, 0, 2) == \"MA\") && (iSWVersion > 36))
      bSNValid = true;
			
    // Check if a software minor version should exist (only after MA41)
    if ((substr(sSwVersion, 0, 2) == \"MA\") && (iSWVersion > 41))
      bSubVersionValid = true;
  }
	
  // Set controls depending on SW version
  if (!bSNValid)
    txtSerialNumber.text = \"N/A\";
		
  if (bSubVersionValid) {
    lblDash.visible = true;
    txtSwSubVer.visible = true;
  } else {
    lblDash.visible = false;
    txtSwSubVer.visible = false;
  }

  // Return to calling routine
  return;
}" 0
 E
14 6
"txtHwVer"
""
1 130 60 E E E 1 E 1 E N "_WindowText" E N "_3DFace" E E
 E E
7 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 128 58 182 85
2 "0s" 0 0 0 0 0 -1  E "main()
{
// Local Variables
// ---------------
  string sElmbName;

// Executable Code
// ---------------
  if (pnlGetElmbName($sDpName, sElmbName)) {
	
    // Connect to the SW version information
    dpConnect(\"cbkHWVersion\", false,
              sElmbName + \".hwVersion\");
  }
	
  // Return to calling routine
  return;			  
}

void cbkHWVersion(string sHWVersionDpe, unsigned uHWVersion)
{
// Local Variables
// ---------------
  string sHwVersion;

// Executable Code
// ---------------
  pnlIntToString(uHWVersion, sHwVersion);
  txtHwVer.text = sHwVersion;

  // Return to calling routine
  return;
}
" 0
 E
14 7
"txtSwSubVer"
""
1 200 30 E E E 1 E 0 E N "_WindowText" E N "_3DFace" E E
 E E
8 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 198 28 252 55
2 "0s" 0 0 0 0 0 -1  E "main()
{
// Local Variables
// ---------------
  string sElmbName;

// Executable Code
// ---------------
  if (pnlGetElmbName($sDpName, sElmbName)) {
	
    // Connect to the SW version information
    dpConnect(\"cbkSWSubVersion\", false,
              sElmbName + \".swMinorVersion\");
  }

  // Return to calling routine
  return;
}

void cbkSWSubVersion(string sSWSubVersionDpe, unsigned uSWSubVersion)
{
// Local Variables
// ---------------
  string sSwSubVersion;

// Executable Code
// ---------------
  pnlIntToString(uSWSubVersion, sSwSubVersion);
  txtSwSubVer.text = sSwSubVersion;

  // Return to calling routine
  return;
}
" 0
 E
14 8
"txtSerialNumber"
""
1 130 90 E E E 1 E 1 E N "_WindowText" E N "_3DFace" E E
 E E
9 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 128 88 182 115
2 "0s" 0 0 0 0 0 -1  E "main()
{
// Local Variables
// ---------------
	string sElmbName;

// Executable Code
// ---------------
	if (pnlGetElmbName($sDpName, sElmbName)) {
	
		// Connect to the SW version information
		dpConnect(\"cbkSerialNumber\", false,
						  sElmbName + \".serialNumber\");
	}

	// Return to calling routine
	return;
}

void cbkSerialNumber(string sSerialNumberDpe, unsigned uSerialNumber)
{
// Local Variables
// ---------------
	string sSN;

// Executable Code
// ---------------
	// Get any text from the SW version field
	pnlIntToString(uSerialNumber, sSN);
	txtSerialNumber.text = sSN;

	// Return to calling routine
	return;
}
" 0
 E
0
LAYER, 1 
1
LANG:1 6 Layer2
0
LAYER, 2 
1
LANG:1 6 Layer3
0
LAYER, 3 
1
LANG:1 6 Layer4
0
LAYER, 4 
1
LANG:1 6 Layer5
0
LAYER, 5 
1
LANG:1 6 Layer6
0
LAYER, 6 
1
LANG:1 6 Layer7
0
LAYER, 7 
1
LANG:1 6 Layer8
0
0