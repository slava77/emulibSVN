#uses "majority_treeCache/treeCache.ctl"
#uses "majority_treeCache/majorityLib.ctl"
#uses "CMS_CSCfw_Supervisor/mudcs3SuperCreateCentralDcsFsm.ctl"

dyn_string majorityTopNodes;

const bool EMUMAJ_DELETE_TREE_CACHE_AND_MAJORITY_CONF = true;
const bool EMUMAJ_CREATE_TREE_CACHE = true;
const bool EMUMAJ_CREATE_MAJORITY_CONF = true;
const bool EMUMAJ_DELETE_MAJORITY_DUS = true;
const bool EMUMAJ_CREATE_MAJORITY_DUS = true;
const bool EMUMAJ_UPDATE_FSM_TYPES = true;
const bool EMUMAJ_OVERWRITE_FSM_TYPE_BACKUPS = false;
const bool EMUMAJ_RESTORE_FSM_TYPES = false;

const long EMUMAJ_SUPERVISOR_INSTALLATION_START_TIMEOUT = 5*60; // 5 minutes
const long EMUMAJ_SUPERVISOR_INSTALLATION_FINISH_TIMEOUT = 2*60*60; // 2 hours

bool isSupervisor;

main()
{
  setFsmAccessControl();
  emumaj_debug("Access Control has been set.", true);
  
  dyn_string ex;
  
  // define the top nodes
  majorityTopNodes = makeDynString("CMS_CSC");//, "CMS_CSC_PLUS", "CMS_CSC_MINUS");
  // system names used by supervisor to delete tree cache and majority conf DPs
  dyn_string sysNames = makeDynString("cms_csc_dcs_09",
                                      "cms_csc_dcs_00",
                                      "cms_csc_dcs_02",
                                      "cms_csc_dcs_07",
                                      "cms_csc_dcs_08",
                                      "cms_csc_dcs_01",
                                      "cms_csc_dcs_10");
  
  // stop FSM if it's going to be modified
  if (EMUMAJ_CREATE_MAJORITY_DUS || EMUMAJ_DELETE_MAJORITY_DUS || EMUMAJ_UPDATE_FSM_TYPES || EMUMAJ_RESTORE_FSM_TYPES) {
    fwFsm_stopAllDomains();
  }

  isSupervisor = isSupervisor();
  // supervisor stuff
  if (isSupervisor) {
    updateInstallationDp("Installation started");

    // DELETE TREE CACHE + MAJORITY DPs
    if (EMUMAJ_DELETE_TREE_CACHE_AND_MAJORITY_CONF) {
      emumaj_debug("Deleting tree cache and majority DPs", true);
      emumaj_deleteTreeCacheAndMajorityDps(sysNames, ex);
      if (emu_checkException(ex)) {
        emumaj_debug("Error while deleting tree cache and majority DPs: " + ex[1], true);
        return;
      }
    }
    
    // TREE CACHE    
    if (EMUMAJ_CREATE_TREE_CACHE) {
      for (int i=1; i <= dynlen(majorityTopNodes); i++) {
        emumaj_debug("Creating tree cache for " + majorityTopNodes[i], true);
        bool ok = emumaj_createTreeCache(majorityTopNodes[i]);
        if (!ok) {
          emumaj_debug("Aborting installation due to error whil creating tree cache for " + majorityTopNodes[i], true);
          return;
        }
      }
    }
    
    // MAJORITY CONF.
    if (EMUMAJ_CREATE_MAJORITY_CONF) {
      for (int i=1; i <= dynlen(majorityTopNodes); i++) {
        emumaj_debug("Creating majority configuration for " + majorityTopNodes[i], true);
        emumaj_createMajorityConfiguration(majorityTopNodes[i]);
      }
    }
    majority_setAccessControl_required_privilege("CMS_CSC", "CMS_CSC:Debug");
    
    emumaj_debug("Supervisor DONE", true);
  } else if (EMUMAJ_CREATE_MAJORITY_DUS || EMUMAJ_UPDATE_FSM_TYPES){
    // wait for supervisor machine to finish it's installation part first  
    bool install = false;
    int waitCounter = 0; // will increase when waiting for supervisor to start installation (installation on the current machine will be terminated if this counter reaches a certain threshold), but it's set to -1 when the installation is started on supervisor - so the timeout is cancelled
    while (!install) {
      if (waitCounter >= EMUMAJ_SUPERVISOR_INSTALLATION_START_TIMEOUT / 30) { // timeout in supervisor starting the installation - just quit
        emumaj_debug("installation canceled - supervisor didn't start the installation within " + EMUMAJ_SUPERVISOR_INSTALLATION_START_TIMEOUT + "s", true);
        return;
      }
      if (waitCounter >= 0) { // supervisor hasn't started the installation yet
        emumaj_debug("Waiting for supervisor to start installation... (will timeout in " + (EMUMAJ_SUPERVISOR_INSTALLATION_START_TIMEOUT - (30 * waitCounter)) + "s)", true);
      } else { // supervisor has started the installation, but hasn't finished yet
        emumaj_debug("Waiting for supervisor to finish installation... (timeout is " + EMUMAJ_SUPERVISOR_INSTALLATION_FINISH_TIMEOUT + "s)", true);
      }
      delay(30);
      dyn_string installationDps = dpNames("*:MAJORITY_INSTALLATION", "MUDCS_MAJORITY_STRING");
      for (int i=1; i <= dynlen(installationDps); i++) {
        // get the installation msg
        string message;
        dpGet(installationDps[i] + ".value", message);
        // get msg update time
        time messageUpdateTime;
        string msgUpdateTimeDp = dpSubStr(installationDps[i] + ".value", DPSUB_SYS_DP_EL) + ":_online.._stime";
        dpGet(msgUpdateTimeDp, messageUpdateTime);
  
        //installation in supervisor hasn't started yet
        if (strpos(message, "Supervisor") >= 0) {
          if (waitCounter >= 0) {
            if (getCurrentTime() - messageUpdateTime <= EMUMAJ_SUPERVISOR_INSTALLATION_START_TIMEOUT) { // if the DP was updated in last EMUMAJ_SUPERVISOR_INSTALLATION_START_TIMEOUT seconds - installation in supervisor has started
              waitCounter = -1; // stop the timeout counter
              emumaj_debug("Supervisor started the installation - disabling the timeout counter and waiting for it to finish", true);
            }
          } else { // installation in supervisor has started - wait for it to finish
            if (message == "Supervisor: Supervisor DONE") {
              emumaj_debug("installation started", true);
              install = true;
            } else if (message == "CANCEL") {
              emumaj_debug("installation canceled", true);
              return;
            } else if (getCurrentTime() - messageUpdateTime > EMUMAJ_SUPERVISOR_INSTALLATION_FINISH_TIMEOUT) { // supervisor installation timeout
              emumaj_debug("installation canceled because supervisor installation hasn't finished in " + EMUMAJ_SUPERVISOR_INSTALLATION_FINISH_TIMEOUT + "s", true);
              return;
            }
          }
        }
      }
      if (waitCounter >= 0) {
        waitCounter++;
      }
      
    }
  }
  
  if (EMUMAJ_DELETE_MAJORITY_DUS) {
    emumaj_debug("Deleting majority DUs");
    emumaj_deleteMajorityDUs();
  }
  
  if (EMUMAJ_CREATE_MAJORITY_DUS) {
    emumaj_debug("Creating majority DUs");
    createMajorityDUs();
  }

  if (EMUMAJ_RESTORE_FSM_TYPES) {
    emumaj_debug("Restoring FSM types");
    emumaj_restoreFsmTypes();
  }
  
  if (EMUMAJ_UPDATE_FSM_TYPES) {
    emumaj_debug("Updating FSM types");
    emumaj_updateFsmTypes();
  }

    
  if (EMUMAJ_CREATE_MAJORITY_DUS || EMUMAJ_DELETE_MAJORITY_DUS || EMUMAJ_UPDATE_FSM_TYPES || EMUMAJ_RESTORE_FSM_TYPES) {
    fwFsmTree_generateAll();
    fwFsmTree_refreshTree();
  }  
  
  emumaj_debug("Adding majority manager");
  fwInstallation_appendManager(TRUE, "Majority", "PVSS00ctrl", "always", 30, 2, 2, "CMS_CSC_majority/majority.ctl");
  
  if (!isSupervisor) {
    emumaj_debug("installation finished", true);
  }
}

void setFsmAccessControl() {
  dyn_string rootNodes, ex;
  fwTree_getChildren("FSM", rootNodes, ex);
  if (dynlen(ex) > 0) { DebugTN("ERROR: " + ex); return; }
  for (int i=1; i <= dynlen(rootNodes); i++) {
    DebugTN("Setting access control for " + rootNodes[i]);
    fwFsmTree_accessTreeNodeRec(rootNodes[i], "CMS_CSC:Control|CMS_CSC:Debug", 1);
  }
  DebugTN("DONE setting FSM access control");
}

void emumaj_debug(string msg, bool putToInstallationDp = false) {
  if (isSupervisor) {
    msg = "Supervisor: " + msg;
  }
  DebugTN("Majority installation: " + msg);
  if (putToInstallationDp) {
    updateInstallationDp(msg);
  }
}

void updateInstallationDp(string msg) {
  dpSetWait("MAJORITY_INSTALLATION.value", msg);
}

bool isSupervisor() {
  dyn_string children;
  dyn_string ex;
  fwTree_getChildren("FSM", children, ex);
  
  bool isSupervisor = false;
  for (int i=1; i <= dynlen(majorityTopNodes); i++) {
    if (dynContains(children, majorityTopNodes[i])) {
      isSupervisor = true;
    }
  }
  return isSupervisor;
}

void emumaj_deleteTreeCacheAndMajorityDps(dyn_string systemNamesToDelete, dyn_string &exception_info) {
  dyn_string dpTypesToDelete = makeDynString("majority",
                                             "majorityConfig",
                                             "majorityCounts",
                                             "majorityStruct",
                                             "treeCache",
                                             "treeCache_included");

  string searchPattern = "{";
  for (int i=1; i <= dynlen(systemNamesToDelete); i++) {
    if (i > 1) {
      searchPattern += ",";
    }
    searchPattern += systemNamesToDelete[i];
  }
  searchPattern += "}:*";
  
  for (int i=1; i <= dynlen(dpTypesToDelete); i++) {
    dyn_string dpsToDelete = dpNames(searchPattern, dpTypesToDelete[i]);
    emumaj_debug("Deleting DPs of type " + dpTypesToDelete[i] + " (" + dynlen(dpsToDelete) + ")", true);
    for (int j=1; j <= dynlen(dpsToDelete); j++) {
      int rc = dpDelete(dpsToDelete[j]);
      if (rc < 0) {
        dynAppend(exception_info, "Error while deleting " + dpsToDelete[j] + " (of type " + dpTypesToDelete[i] + ")");
        return;
      }
    }
  }
}

void emumaj_deleteMajorityDUs() { 

//   _removeFromFwTreeNodesAsChildren();
//   return;
   
  dyn_string ex;
  dyn_string nodes;
  dyn_string allTypes;  
  
    
  fwTree_getAllTreeNodes("FSM", nodes, ex);
  if (emu_checkException(ex)) { return; }  
  for(int i=1; i <= dynlen(nodes); i++) {
    if (strpos(nodes[i], "&") >= 0) { continue; }
    string type;
    fwCU_getType(nodes[i], type);
    if (type == "majority") {
      DebugTN("   Deleting " + nodes[i] + "...");
//       string domain = nodes[i];
//       string object = _fwCU_getNodeObj(domain);
      string parent;
      fwTree_getParent(nodes[i], parent, ex);
      if (emu_checkException(ex)) { return; }  
      fwFsmTree_removeNode(parent, nodes[i], 0);
//       fwTree_removeNode(parent, nodes[i], ex);
//       if (emu_checkException(ex)) { return; }  
    }
  }  
  
  DebugTN("DONE");
}

bool emumaj_createTreeCache(string majorityTopNode) {
  dyn_string exceptionInfo;
  // exclude the duplicate nodes - nodes which reference nodes already included in other parts of the FSM tree
  dyn_string excludedNodes = makeDynString("node=CSC_ME_P11_HV",
                                           "node=CSC_ME_N11_HV",
                                           "node=LV_MRTN_MINUS",
                                           "node=LV_MRTN_PLUS");
  
  treeCache_create(majorityTopNode, excludedNodes, exceptionInfo);

  if (dynlen(exceptionInfo) > 0) {
    DebugTN("Error creating tree cache: ");
    DebugTN(exceptionInfo);
    return false;
  }
  
  // create and set the dp functions in the treeCache_included* datapoints
  treeCache_initIncluded(majorityTopNode);
  if (dynlen(exceptionInfo) > 0) {
    DebugTN("Error creating tree cache included info: ");
    DebugTN(exceptionInfo);
    return false;
  }
  
  return true;
}

void emumaj_createMajorityConfiguration(string majorityTopNode) {
  majority_new(majorityTopNode); // you may want to pass a second parameter that is the treeCache topNode if you need to use 
  //  the same treeCache but with different topNodes for different majorities
  majority_deleteConfig(majorityTopNode);  

  DebugTN("Creating HV majority");
  configureHv(majorityTopNode);
  DebugTN("Creating ME1/1 HV majority");
  configureME11Hv(majorityTopNode);
  DebugTN("Creating HV Primary majority");
  configureHVPrimaries(majorityTopNode);
  DebugTN("Creating LV majority");
  configureLv(majorityTopNode);
  DebugTN("Creating Temperature majority");
  configureTemp(majorityTopNode);
  DebugTN("Creating CRB majority");
  configureCrb(majorityTopNode);
  DebugTN("Creating Maraton Channel majority");
  configureMaratonChannel(majorityTopNode);
  DebugTN("Creating Maraton Crate majority");
  configureMaratonCrate(majorityTopNode);
  DebugTN("Creating DDU majority");
  configureDDU(majorityTopNode);
  DebugTN("Creating Atlas PSU branch majority");
  configureAtlasPSU(majorityTopNode);
  DebugTN("Creating GAS majority (top device only)");
  configureGas(majorityTopNode);
//  DebugTN("Creating COOLING majority (top device only)");
//  configureCooling(majorityTopNode);

  DebugTN("Creating general majority parameters");
  
  // Configure the polling: for each node, define the number of polls, the poll_time in milliseconds and the maximum number of polls
  //  Possible values could be 100,2 
 
  majority_clearPollConfig();
//  majority_addPollConfig(majorityTopNode, 3, 500, 30);

  // OR: If you want you can try to use the automaticConfig that tries to change the polling time depending on the number of children of each node 
  //   In this case you define a mean poll time (divided in 1 or 2 polls) and a max number of rejected threads. Possible values  100, 2
  // IF YOU USE THE AUTOMATIC CONFIGURATION, YOU DO NOT NEED TO CALL THE PREVIOUS TWO FUNCTIONS (majority_clearPollConfig and majority_addPollConfig)
  majority_automaticConfig(100, 2);

  // this is the refresh of the datapoints from the map in memory (500 ms should be ok)
  majority_setRefresh(500);

  // then create the majority
  // to change the configuration you will need to repeat the steps after addPercentages and call again majority_create

  majority_create();
}

void createMajorityDUs() { 
  dyn_string ex;
  dyn_string nodes;
  dyn_string allTypes;  
  
    
  fwTree_getAllTreeNodes("FSM", nodes, ex);
  if (emu_checkException(ex)) { return; }  
  for(int i=1; i <= dynlen(nodes); i++) {
    DebugTN("  processing node " + nodes[i]);
    if (strpos(nodes[i], "&") >= 0) { 
      DebugTN("  skipping " + nodes[i] + " - reference");
      continue;
    }
    string type;
    fwCU_getType(nodes[i], type);
    string domain = nodes[i];
    string object = _fwCU_getNodeObj(domain);
    bool isDU = fwFsm_isDU(domain, object);
    if (isDU) { continue; }
    
    if (fwFsmTree_isNode("majority_" + nodes[i])) { 
      DebugTN("  skipping majority_" + nodes[i] + " - node already exists");
      continue;
    }
    fwFsmTree_addNode(nodes[i], "majority_" + nodes[i], "majority", 0);   
    fwFsmTree_setNodeVisibility("majority_" + nodes[i], 0);
    DebugTN("    majority DU created in " + nodes[i] + " - " + type);
    if (!dynContains(allTypes, type)) {
      dynAppend(allTypes, type);
    }
  }

  DebugTN("All non-DU types that were found:");
  for (int i=1; i <= dynlen(allTypes); i++) {
    DebugTN("    " + allTypes[i]);
  }
  
  DebugTN("DONE");
}

// in case CMS_CSC_common is not installed
bool emu_checkException(dyn_string &exceptionInfo, string higherLevelMsg = "") {
  if (dynlen(exceptionInfo) > 0) {
    DebugTN("ERROR:");
    DebugTN(exceptionInfo);
    return true;
  }
  return false;
}

void emumaj_updateFsmTypes() {
  dyn_string typesToUpdate = makeDynString("CSC_LV_NODES",
                                           "CSC_LV_HV",
                                           "CSC_LV_TREE_NODES",
                                           "EMUFEDNodes",
                                           "EMUNodes",
                                           "EMUSTBYNodes",
                                           "EMUTREESTBYNodes",
                                           "EMUTREENodes",
                                           "EMUTREENodes_I",
                                           "EMUTREENodes_O",
                                           "EMUTREENodes_S",
                                           "CMS_CSC_ME11_HV_Type");
  
  for (int i=1; i <= dynlen(typesToUpdate); i++) {
    string typeDp = "fwOT_" + typesToUpdate[i];
    if (!dpExists(typeDp)) {
      continue;
    }
    bool exists = dpExists(typeDp + "_majBackup");
    if (!exists || EMUMAJ_OVERWRITE_FSM_TYPE_BACKUPS) {
      int error;
      if (!exists) {
        dpCopy(typeDp, typeDp + "_majBackup", error);
      }
      string panel;
      dyn_string components, states, actions, parameters;
      dpGet(typeDp + ".panel", panel,
            typeDp + ".components", components,
            typeDp + ".states", states,
            typeDp + ".actions", actions,
            typeDp + ".parameters", parameters);
      dpSetWait(typeDp + "_majBackup.panel", panel,
                typeDp + "_majBackup.components", components,
                typeDp + "_majBackup.states", states,
                typeDp + "_majBackup.actions", actions,
                typeDp + "_majBackup.parameters", parameters);
    }
    
    dyn_string states = makeDynString("OFF",
                                      "FwStateOKNotPhysics",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "ERROR",
                                      "FwStateAttention3",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "ON",
                                      "FwStateOKPhysics",
                                      "when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "STANDBY",
                                      "FwStateOKNotPhysics",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "OUTER_ON",
                                      "FwStateAttention1",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "NOT-READY",
                                      "FwStateAttention1",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|",
                                      "",
                                      "");
    dpSetWait(typeDp + ".states", states);
  }
}

void emumaj_restoreFsmTypes() {
  dyn_string typesToUpdate = makeDynString("CSC_LV_NODES",
                                           "CSC_LV_HV",
                                           "CSC_LV_TREE_NODES",
                                           "EMUFEDNodes",
                                           "EMUNodes",
                                           "EMUSTBYNodes",
                                           "EMUTREESTBYNodes",
                                           "EMUTREENodes",
                                           "EMUTREENodes_I",
                                           "EMUTREENodes_O",
                                           "EMUTREENodes_S",
                                           "CMS_CSC_ME11_HV_Type");
  
  for (int i=1; i <= dynlen(typesToUpdate); i++) {
    string typeDp = "fwOT_" + typesToUpdate[i];
    if (!dpExists(typeDp)) {
      continue;
    }
    if (dpExists(typeDp + "_majBackup")) {
//      int error;
//      dpCopy(typeDp + "_majBackup", typeDp, error);
      string panel;
      dyn_string components, states, actions, parameters;
      dpGet(typeDp + "_majBackup.panel", panel,
            typeDp + "_majBackup.components", components,
            typeDp + "_majBackup.states", states,
            typeDp + "_majBackup.actions", actions,
            typeDp + "_majBackup.parameters", parameters);
      dpSetWait(typeDp + ".panel", panel,
                typeDp + ".components", components,
                typeDp + ".states", states,
                typeDp + ".actions", actions,
                typeDp + ".parameters", parameters);
    }
  }  
}

// CSC majority configuration
void configureHv(string topNode) {
  majority_addDevice("HV_OUTER", // this defines the internal name of the device for the majority
  "CscHvChamber", // this is the corresponding Device Unit Type
  makeDynString(".channel_states"), // define the datapoint elements you need to connect
  makeDynString("on", "standby", "ramping", "error"), // these are the basic device states for this device
  -1 // because it can be either an 18 or a 30 channel chamber, we set the weight to -1 so that it would be calculated in majorityUser_getDeviceWeight(...)
  );
            
  majority_addDevice("HV_INNER", // this defines the internal name of the device for the majority
  "CscHvChamber", // this is the corresponding Device Unit Type
  makeDynString(".channel_states"), // define the datapoint elements you need to connect
  makeDynString("on", "standby", "ramping", "error"), // these are the basic device states for this device
  -1 // because it can be either an 18 or a 30 channel chamber, we set the weight to -1 so that it would be calculated in majorityUser_getDeviceWeight(...)
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
            
  majority_addColors("HV_OUTER", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_OUTER", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_OUTER", "ramping", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_OUTER", "error", majority_getStandardColorsError() );    

  majority_addColors("HV_INNER", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_INNER", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_INNER", "ramping", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_INNER", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "HV_OUTER", makeDynFloat(97, 97, 3, 3)); // here you define the thresholds for the percentages: in this case we have 97% for ON and STANDBY and 3% for ERROR or RAMPING
  majority_addPercentages(topNode, "HV_INNER", makeDynFloat(97, 97, 3, 3)); // here you define the thresholds for the percentages: in this case we have 97% for ON and STANDBY and 3% for ERROR or RAMPING
}

void configureLv(string topNode) {
  majority_addDevice("LV", // this defines the internal name of the device for the majority
  "CscLvChamber", // this is the corresponding Device Unit Type
  makeDynString(".fsm_state", ".disabled_channels"), // define the datapoint elements you need to connect
  makeDynString("on", "error", "no_communication"), // these are the basic device states for this device
  -1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("LV", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("LV", "error", majority_getStandardColorsError() );    
  majority_addColors("LV", "no_communication", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "LV", makeDynFloat(95, 5, 40)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureTemp(string topNode) {
  majority_addDevice("TEMP", // this defines the internal name of the device for the majority
  "CscTempChamber", // this is the corresponding Device Unit Type
  makeDynString(".fsm_state", ".disabled_channels"), // define the datapoint elements you need to connect
  makeDynString("ok", "alert", "no_communication"), // these are the basic device states for this device
  -1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("TEMP", "ok", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("TEMP", "alert", majority_getStandardColorsError() );    
  majority_addColors("TEMP", "no_communication", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "TEMP", makeDynFloat(95, 5, 40)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureCrb(string topNode) {
  majority_addDevice("CRB", // this defines the internal name of the device for the majority
  "fwCrb_CSC_LV", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("CRB", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("CRB", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "CRB", makeDynFloat(99, 1)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureMaratonChannel(string topNode) {
  majority_addDevice("MrtnChannel", // this defines the internal name of the device for the majority
  "FwWienerMarathonChannel", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("MrtnChannel", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("MrtnChannel", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "MrtnChannel", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureMaratonCrate(string topNode) {
  majority_addDevice("MrtnCrate", // this defines the internal name of the device for the majority
  "FwWienerMarathon", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("MrtnCrate", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("MrtnCrate", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "MrtnCrate", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureDDU(string topNode) {
  majority_addDevice("DDU", // this defines the internal name of the device for the majority
  "CscFedDdu", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("DDU", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("DDU", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "DDU", makeDynFloat(95, 6)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureAtlasPSU(string topNode) {
  // Atlas PSU branch
  majority_addDevice("AtlasPSU_Branch", // this defines the internal name of the device for the majority
  "FwElmbPSUBranch", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("AtlasPSU_Branch", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("AtlasPSU_Branch", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "AtlasPSU_Branch", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureHVPrimaries(string topNode) {
  // HV Primary supplies
  majority_addDevice("HV_Primary", // this defines the internal name of the device for the majority
  "CscHvPrimary", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "standby", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("HV_Primary", "on", majority_getStandardColorsPhysics() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_Primary", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_Primary", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "HV_Primary", makeDynFloat(100, 100, 0));
}

void configureME11Hv(string topNode) {
  // ME1/1 HV
  majority_addDevice("HV_ME11", // this defines the internal name of the device for the majority
  "FwCaenChannel", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "standby", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("HV_ME11", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_ME11", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_ME11", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "HV_ME11", makeDynFloat(95, 95, 3)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureGas(string topNode) {
  //GAS - top (global) device only
  majority_addDevice("Gas", // this defines the internal name of the device for the majority
  "CscGasSystem_CSC_GAS", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("Gas", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("Gas", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "Gas", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureCooling(string topNode) {
  //GAS - top (global) device only
  majority_addDevice("Cooling", // this defines the internal name of the device for the majority
  "CscCooling_CSC_COOLING", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("Cooling", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("Cooling", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "Cooling", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}
