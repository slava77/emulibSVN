V 11
1
LANG:1 0 
PANEL,-1 -1 388 123 N "_3DFace" 5
"$deviceParams"
"$deviceType"
"$mode"
"$refName"
"$showInfo"
"main()
{
  dyn_string ex;
  mapping deviceParams = emuui_parseParameterString($deviceParams, ex);
  if (emu_checkException(ex)) { return; }  
  
  //initialize some panel-wide variables and constants
  initTooltipSize();
  panelSize(\"\", screenSizeX, screenSizeY);
  getCursorPosition(tooltipX, tooltipY);
  tooltipX += EMUUI_TOOLTIP_SHIFT_X;
  
  float zoomFactor;
  getZoomFactor(zoomFactor);
  
  tooltipX /= zoomFactor;
  tooltipY /= zoomFactor;
  
  //add Caption - device name
  if (addTooltipObj($deviceType + \"_name\") == \"\") {
    lblError.visible = true;
    return;
  }

  //check if it's an ME11 chamber
  bool me11 = false;
  if (($deviceType == \"chamber\") && (deviceParams[\"station\"] == 1) && (deviceParams[\"ring\"] == 1)) {
    me11 = true;
  }
  
  dyn_string ex;
  string tooltipTypesCombined = emuui_getMappingValue(\"modeToTooltipObj\", $mode, ex); // get the tooltip types given the device connection mode
  if (dynlen(ex)) { // if the tooltip type is missing - no problem, just don't display that tooltip object and log the error
    emu_errorHandled(ex); 
    emu_info(\"Could not find tooltip object mapping for mode: \" + $mode);
    return;
  }
  
  dyn_string tooltipTypes = strsplit(tooltipTypesCombined, \",\");
  for (int i=1; i <= dynlen(tooltipTypes); i++) {
    //special case for ME11 high voltage
    if ((tooltipTypes[i] == \"chamber_high_voltage\") && me11) {
      tooltipTypes[i] = \"chamber_me11_high_voltage\";
    }
    //add the tooltip object
    addTooltipObj(tooltipTypes[i]); // add the appropriate tooltip objects
  }

  //add info tooltip - says that you have to double click for control or more information
  if ($showInfo) {
    int saveTooltipWidth = tooltipWidth;
    string ref = addTooltipObj(\"info\");
    tooltipWidth = saveTooltipWidth;
    setValue(\"info_tooltipBack\", \"size\", tooltipWidth, 21);
  }
  
  
  moveAwayFromEdge();
  
  dpConnect(\"repositionTooltipObjsCB\", false, emuui_getSessionDp(\"tooltipSizeUpdated\"));
}
" 0
 "main()
{
  for (int i=1; i <= dynlen(refObjects); i++) {
    removeSymbol(myModuleName(), myPanelName(), refObjects[i]);
  }
  emuui_tooltipClosed($refName);
}" 0
 E E E 1 -1 -1 0  30 40
""0  1
E "int tooltipHeight, tooltipWidth;
int tooltipX, tooltipY;
int screenSizeX, screenSizeY;
dyn_string refObjects;
dyn_string objTypes;

// shift the tooltip a bit down and right in order not to overlap it with mouse cursor
const int EMUUI_TOOLTIP_SHIFT_X = 8;
const int EMUUI_TOOLTIP_SHIFT_Y = 20;

void initTooltipSize() {
  tooltipHeight = EMUUI_TOOLTIP_SHIFT_Y; // to make the tooltip appear a bit lower than the mouse
  tooltipWidth = 0;
}

string getTooltipObjFile(string type) {
  bool fileFound = false;
  string filename = \"refTooltipObj_\" + type + \".pnl\";
  for (int i=1; i <= SEARCH_PATH_LEN; i++) {
    string test = getPath(PANELS_REL_PATH, EMUUI_OBJECTS_DIR + \"/tooltip_objects\", filename, i);
    if (strlen(test) > 0) { 
      fileFound = true; 
      break;
    }
  }
  
  if (fileFound) {
    return EMUUI_OBJECTS_DIR + \"/tooltip_objects/\" + filename;
  }
  return \"\";
}

/** Adds a tooltip object and returns reference name on success and empty string if it failed (e.g. file was not found). */
string addTooltipObj(string type) {
  string filename = getTooltipObjFile(type);
  if (strlen(filename) == 0) {
    return \"\";
  }
  string refName = filename + $deviceParams;
  // adds the tooltip object in an array of to-be-deleted items when the panel is closed or terminated
  dynAppend(refObjects, refName);
  dynAppend(objTypes, type);
  
  addSymbol(myModuleName(), myPanelName(),
          filename,
          refName,
          makeDynString(\"$deviceParams:\" + $deviceParams),
          tooltipX, tooltipY + tooltipHeight, 0, 1, 1);
  
  updateTooltipSizeVariables(type);
  return refName;
}

/** updates the tooltipHeight and tooltipWidth variable - used to position new tooltipObjects. */
void updateTooltipSizeVariables(string objType) {
  if (shapeExists(objType + \"_tooltipBack\")) {
    int objWidth, objHeight;
    getValue(objType + \"_tooltipBack\", \"size\", objWidth, objHeight);
    tooltipHeight += objHeight - 1;
    if (objWidth > tooltipWidth) {
      tooltipWidth = objWidth;
    }
  } else { // if the background object doesn't exist we cannot really tell what's the height of that tooltipObject, so just lets increase it by let's say 50 so that we notice that problem if we will try to add something in addition to a tooltip object which hasn't got a fixed height (e.g. chamber_general).
    tooltipHeight += 50;
    tooltipWidth = 170;
  }
}

/** if the tooltip hides over the edge of the panel - this function corrects that. */
void moveAwayFromEdge() {
  int myScreenSizeX = screenSizeX;
  int myScreenSizeY = screenSizeY - emuui_g_topMajorityTableHeight;
  
  //avoid the FSM area
  if (tooltipX <= emuui_g_topFsmNodesRightX) { // make the screen size smaller in Y in the are where tooltip X overlaps with FSM nodes X
    myScreenSizeY -= emuui_g_topFsmNodesHeight;
  }
  
  // proceed to move the tooltip away from screen edges
  int hideX, hideY; // number of pixels of tooltip width or hight that is hidden over the edge of the panel
  hideY = (tooltipY + tooltipHeight) - myScreenSizeY;
  hideX = (tooltipX + tooltipWidth) - myScreenSizeX;
  if (hideY < 0) { hideY = 0; } // cut on -0 to avoid funny effects
  if (hideX < 0) { hideX = 0; } // cut on -0 to avoid funny effects
  
  if ((hideY > 0) || (hideX > 0)) {
    hideY += 2;
    for (int i=1; i <= dynlen(refObjects); i++) {
      int objPosX, objPosY;
      getValue(refObjects[i], \"position\", objPosX, objPosY);
      objPosY -= hideY;
      if (hideX > 0) {
        objPosX -= tooltipWidth + (EMUUI_TOOLTIP_SHIFT_X * 2);
        objPosY -= EMUUI_TOOLTIP_SHIFT_Y;
      }
      setValue(refObjects[i], \"position\", objPosX, objPosY);
    }
    // correct the tooltipX & tooltipY
    tooltipY -= hideY;
    if (hideX > 0) {
      tooltipX -= tooltipWidth + (EMUUI_TOOLTIP_SHIFT_X * 2);
      tooltipY -= EMUUI_TOOLTIP_SHIFT_Y;
    }
  }
}

/** This call-back function is called when CSC_UI_sessionState.tooltipSizeChanged datapoint is updated - that happens
    when contents of some tooltip objects change and change the size of the object (e.g. warnings are added or removed).
    On such an event this function repositions all the tooltip objects so that they don't overlap. */
void repositionTooltipObjsCB(string dummyDpName, int dummyValue) {
  initTooltipSize();
  for (int i=1; i <= dynlen(refObjects); i++) {
    setValue(refObjects[i], \"position\", tooltipX, tooltipY + tooltipHeight);
    updateTooltipSizeVariables(objTypes[i]);
  }
  
  moveAwayFromEdge();
  
  dpSetWait(emuui_getSessionDp(\"tooltipPositionUpdated\"), 1);
}" 0
 2
"CBRef" "1"
"EClose" "main()
{
  for (int i=1; i <= dynlen(refObjects); i++) {
    removeSymbol(myModuleName(), myPanelName(), refObjects[i]);
  }
  emuui_tooltipClosed($refName);
}" 0

""
DISPLAY_LAYER, 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
LAYER, 0 
1
LANG:1 0 
2 0
"PRIMITIVE_TEXT1"
""
1 30 40 E E E 1 E 0 E N "_WindowText" E N "_Window" E E
 E E
0 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 30 40 335 54
0 2 2 "0s" 0 0 0 192 0 0  30 40 1
1
LANG:1 33 MS Shell Dlg,-1,11,5,50,0,0,0,0,0
0 1
LANG:1 66 Content is dynamically generated - see initialize event & scopeLib
2 2
"lblError"
""
1 0 0 E E E 1 E 0 E N "_WindowText" E N "FwStateAttention3" E E
 E E
2 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 0 0 375 14
0 2 2 "0s" 0 0 0 192 0 0  0 0 1
1
LANG:1 33 MS Shell Dlg,-1,11,5,50,0,0,0,0,0
0 1
LANG:1 85 Error - tooltip file for this type of device is missing! Please inform DCS developers
0
LAYER, 1 
1
LANG:1 0 
0
LAYER, 2 
1
LANG:1 0 
0
LAYER, 3 
1
LANG:1 0 
0
LAYER, 4 
1
LANG:1 0 
0
LAYER, 5 
1
LANG:1 0 
0
LAYER, 6 
1
LANG:1 0 
0
LAYER, 7 
1
LANG:1 0 
0
0
