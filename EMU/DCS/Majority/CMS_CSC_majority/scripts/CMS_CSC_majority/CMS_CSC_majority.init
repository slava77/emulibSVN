#uses "majority_treeCache/treeCache.ctl"
#uses "majority_treeCache/majorityLib.ctl"

string majorityTopNode = "CMS_CSC";

main()
{
  fwFsm_stopAllDomains();
  bool isSupervisor = isSupervisor();
  if (isSupervisor) {
    updateInstallationDp("installation started");
    DebugTN("Majority installation: creating tree cache");
    bool ok = emumaj_createTreeCache();
    if (!ok) {
      DebugTN("Majority installation: Aborting installation due to error whil creating tree cache");
      updateInstallationDp("Aborting installation due to error whil creating tree cache");
      return;
    }
    DebugTN("Majority installation: tree cache created OK");
  
    DebugTN("Majority installation: deleting majority configuration");
    majority_deleteConfig(majorityTopNode);  
    DebugTN("Majority installation: majority configuration deleted OK");

    DebugTN("Majority installation: creating majority configuration");
    emumaj_createMajorityConfiguration();
    DebugTN("Majority installation: majority configuration created OK");
    updateInstallationDp("Supervisor DONE");
  } else {
    // wait for supervisor machine to finish it's installation part first  
    bool install = false;
    while (!install) {
      DebugTN("Majority installation: Waiting for supervisor to finish...");
      delay(5);
      dyn_string installationDps = dpNames("*:MAJORITY_INSTALLATION", "MUDCS_MAJORITY_STRING");
      for (int i=1; i <= dynlen(installationDps); i++) {
        string message;
        dpGet(installationDps[i] + ".value", message);
        if (message == "Supervisor DONE") {
          updateInstallationDp("installation started");
          install = true;
        }
      }
    }
  }
  
  DebugTN("Majority installation: creating majority DUs");
  createMajorityDUs();
  DebugTN("Majority installation: majority DUs created OK");
  
  DebugTN("Majority installation: Updating FSM types");
  emumaj_updateFsmTypes();
  DebugTN("Majority installation: FSM types updated OK");
  
  DebugTN("Majority installation: adding majority manager");
  fwInstallation_appendManager(TRUE, "Majority", "PVSS00ctrl", "always", 30, 2, 2, "CMS_CSC_majority/majority.ctl");
  DebugTN("Majority installation: majority manager added OK");
  
  if (!isSupervisor) {
    updateInstallationDp("installation finished");
  }
}

void updateInstallationDp(string msg) {
  dpSetWait("MAJORITY_INSTALLATION.value", msg);
}

bool isSupervisor() {
  dyn_string children;
  dyn_string ex;
  fwTree_getChildren("FSM", children, ex);
  
  bool isSupervisor = dynContains(children, majorityTopNode);
  return isSupervisor;
}

bool emumaj_createTreeCache() {
  dyn_string exceptionInfo;
  treeCache_create(majorityTopNode, makeDynString(), exceptionInfo); // give the top node of your hierarchy here

  if (dynlen(exceptionInfo) > 0) {
    DebugTN("Error creating tree cache: ");
    DebugTN(exceptionInfo);
    return false;
  }
  
  // create and set the dp functions in the treeCache_included* datapoints
  treeCache_initIncluded(majorityTopNode);
  if (dynlen(exceptionInfo) > 0) {
    DebugTN("Error creating tree cache included info: ");
    DebugTN(exceptionInfo);
    return false;
  }
  
  return true;
}

void emumaj_createMajorityConfiguration() {
  majority_new(majorityTopNode); // you may want to pass a second parameter that is the treeCache topNode if you need to use 
  //  the same treeCache but with different topNodes for different majorities
  majority_deleteConfig(majorityTopNode);  

  DebugTN("Creating HV majority");
  configureHv(majorityTopNode);
  DebugTN("Creating ME1/1 HV majority");
  configureME11Hv(majorityTopNode);
  DebugTN("Creating HV Primary majority");
  configureHVPrimaries(majorityTopNode);
  DebugTN("Creating LV majority");
  configureLv(majorityTopNode);
  DebugTN("Creating Temperature majority");
  configureTemp(majorityTopNode);
  DebugTN("Creating CRB majority");
  configureCrb(majorityTopNode);
  DebugTN("Creating Maraton Channel majority");
  configureMaratonChannel(majorityTopNode);
  DebugTN("Creating Maraton Crate majority");
  configureMaratonCrate(majorityTopNode);
  DebugTN("Creating DDU majority");
  configureDDU(majorityTopNode);
  DebugTN("Creating LV for HV majority");
  configureLvForHv(majorityTopNode);
  DebugTN("Creating Atlas PSU branch majority");
  configureAtlasPSU(majorityTopNode);
  DebugTN("Creating GAS majority (top device only)");
  configureGas(majorityTopNode);
  DebugTN("Creating COOLING majority (top device only)");
  configureCooling(majorityTopNode);

  DebugTN("Creating general majority parameters");
  
  // Configure the polling: for each node, define the number of polls, the poll_time in milliseconds and the maximum number of polls
  //  Possible values could be 100,2 
 
  majority_clearPollConfig();
//  majority_addPollConfig(majorityTopNode, 3, 500, 30);

  // OR: If you want you can try to use the automaticConfig that tries to change the polling time depending on the number of children of each node 
  //   In this case you define a mean poll time (divided in 1 or 2 polls) and a max number of rejected threads. Possible values  100, 2
  // IF YOU USE THE AUTOMATIC CONFIGURATION, YOU DO NOT NEED TO CALL THE PREVIOUS TWO FUNCTIONS (majority_clearPollConfig and majority_addPollConfig)
  majority_automaticConfig(100, 2);

  // this is the refresh of the datapoints from the map in memory (500 ms should be ok)
  majority_setRefresh(500);

  // then create the majority
  // to change the configuration you will need to repeat the steps after addPercentages and call again majority_create

  majority_create();
}

void createMajorityDUs() { 
  dyn_string ex;
  dyn_string nodes;
  dyn_string allTypes;  
  
    
  fwTree_getAllTreeNodes("FSM", nodes, ex);
  if (emu_checkException(ex)) { return; }  
  for(int i=1; i <= dynlen(nodes); i++) {
    DebugTN("  processing node " + nodes[i]);
    if (strpos(nodes[i], "&") >= 0) { 
      DebugTN("  skipping " + nodes[i] + " - reference");
      continue;
    }
    string type;
    fwCU_getType(nodes[i], type);
    string domain = nodes[i];
    string object = _fwCU_getNodeObj(domain);
    bool isDU = fwFsm_isDU(domain, object);
    if (isDU) { continue; }
    
    if (fwFsmTree_isNode("majority_" + nodes[i])) { 
      DebugTN("  skipping majority_" + nodes[i] + " - node already exists");
      continue;
    }
    fwFsmTree_addNode(nodes[i], "majority_" + nodes[i], "majority", 0);   
    fwFsmTree_setNodeVisibility("majority_" + nodes[i], 0);
    DebugTN("    majority DU created in " + nodes[i] + " - " + type);
    if (!dynContains(allTypes, type)) {
      dynAppend(allTypes, type);
    }
  }

  DebugTN("All non-DU types that were found:");
  for (int i=1; i <= dynlen(allTypes); i++) {
    DebugTN("    " + allTypes[i]);
  }
  
  fwFsmTree_generateAll();
  fwFsmTree_refreshTree();  
  
  DebugTN("DONE");
}

// in case CMS_CSC_common is not installed
bool emu_checkException(dyn_string &exceptionInfo, string higherLevelMsg = "") {
  if (dynlen(exceptionInfo) > 0) {
    DebugTN("ERROR:");
    DebugTN(exceptionInfo);
    return true;
  }
  return false;
}

void emumaj_updateFsmTypes() {
  dyn_string typesToUpdate = makeDynString("CSC_LV_NODES",
                                           "CSC_LV_HV",
                                           "CSC_LV_TREE_NODES",
                                           "EMUFEDNodes",
                                           "EMUNodes",
                                           "EMUSTBYNodes",
                                           "EMUTREESTBYNodes",
                                           "EMUTREENodes",
                                           "EMUTREENodes_I",
                                           "EMUTREENodes_O",
                                           "EMUTREENodes_S",
                                           "CMS_CSC_ME11_HV_Type");
  
  for (int i=1; i <= dynlen(typesToUpdate); i++) {
    string typeDp = "fwOT_" + typesToUpdate[i];
    if (!dpExists(typeDp)) {
      continue;
    }
    if (!dpExists(typeDp + "_majBackup")) {
      int error;
      dpCopy(typeDp, typeDp + "_majBackup", error);
      string panel;
      dyn_string components, states, actions, parameters;
      dpGet(typeDp + ".panel", panel,
            typeDp + ".components", components,
            typeDp + ".states", states,
            typeDp + ".actions", actions,
            typeDp + ".parameters", parameters);
      dpSetWait(typeDp + "_majBackup.panel", panel,
                typeDp + "_majBackup.components", components,
                typeDp + "_majBackup.states", states,
                typeDp + "_majBackup.actions", actions,
                typeDp + "_majBackup.parameters", parameters);
    }
    
    dyn_string states = makeDynString("OFF",
                                      "FwStateOKNotPhysics",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "ERROR",
                                      "FwStateAttention3",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "ON",
                                      "FwStateOKPhysics",
                                      "when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "STANDBY",
                                      "FwStateAttention1",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "OUTER_ON",
                                      "FwStateAttention1",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|when ( $ALL$majority in_state NOT-READY )  move_to NOT-READY|",
                                      "",
                                      "",
                                      "NOT-READY",
                                      "FwStateAttention1",
                                      "when ( $ALL$majority in_state ON )  move_to ON|when ( $ALL$majority in_state OUTER_ON )  move_to OUTER_ON|when ( $ALL$majority in_state STANDBY )  move_to STANDBY|when ( $ALL$majority in_state OFF )  move_to OFF|when ( $ALL$majority in_state ERROR )  move_to ERROR|",
                                      "",
                                      "");
    dpSetWait(typeDp + ".states", states);
  }
}


// CSC majority configuration
void configureHv(string topNode) {
  majority_addDevice("HV_OUTER", // this defines the internal name of the device for the majority
  "HV_1", // this is the corresponding Device Unit Type
  makeDynString(".status",".off_channels", ".last_vset"), // define the datapoint elements you need to connect
  makeDynString("on","standby","error"), // these are the basic device states for this device
  18 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
            
  majority_addDevice("HV_INNER", // this defines the internal name of the device for the majority
  "HV_1", // this is the corresponding Device Unit Type
  makeDynString(".status",".off_channels", ".last_vset"), // define the datapoint elements you need to connect
  makeDynString("on","standby","error"), // these are the basic device states for this device
  18 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
            
  majority_addColors("HV_OUTER", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_OUTER", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_OUTER", "error", majority_getStandardColorsError() );    

  majority_addColors("HV_INNER", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_INNER", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_INNER", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "HV_OUTER", makeDynFloat(95, 95, 5)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
  majority_addPercentages(topNode, "HV_INNER", makeDynFloat(95, 95, 5)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureLv(string topNode) {
  majority_addDevice("LV", // this defines the internal name of the device for the majority
  "LV_1", // this is the corresponding Device Unit Type
  makeDynString(".status", ".chamber_state", ".noalert_channels"), // define the datapoint elements you need to connect
  makeDynString("on", "error", "no_communication"), // these are the basic device states for this device
  19 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("LV", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("LV", "error", majority_getStandardColorsError() );    
  majority_addColors("LV", "no_communication", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "LV", makeDynFloat(95, 5, 40)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureTemp(string topNode) {
  majority_addDevice("TEMP", // this defines the internal name of the device for the majority
  "TEMP_1", // this is the corresponding Device Unit Type
  makeDynString(".status", ".chamber_state", ".off_channels"), // define the datapoint elements you need to connect
  makeDynString("ok", "alert", "no_communication"), // these are the basic device states for this device
  7 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("TEMP", "ok", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("TEMP", "alert", majority_getStandardColorsError() );    
  majority_addColors("TEMP", "no_communication", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "TEMP", makeDynFloat(95, 5, 40)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureCrb(string topNode) {
  majority_addDevice("CRB", // this defines the internal name of the device for the majority
  "fwCrb_CSC_LV", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("CRB", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("CRB", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "CRB", makeDynFloat(99, 1)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureMaratonChannel(string topNode) {
  majority_addDevice("MrtnChannel", // this defines the internal name of the device for the majority
  "FwWienerMarathonChannel", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("MrtnChannel", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("MrtnChannel", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "MrtnChannel", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureMaratonCrate(string topNode) {
  majority_addDevice("MrtnCrate", // this defines the internal name of the device for the majority
  "FwWienerMarathon", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("MrtnCrate", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("MrtnCrate", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "MrtnCrate", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureDDU(string topNode) {
  majority_addDevice("DDU", // this defines the internal name of the device for the majority
  "FED_1", // this is the corresponding Device Unit Type
  makeDynString(".status", ".off_channels"), // define the datapoint elements you need to connect
  makeDynString("on", "error", "no_communication"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("DDU", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("DDU", "error", majority_getStandardColorsError() );    
  majority_addColors("DDU", "no_communication", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "DDU", makeDynFloat(95, 6, 40)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureLvForHv(string topNode) {
  // LV for HV Wiener Crate
  majority_addDevice("LvForHv_Cr", // this defines the internal name of the device for the majority
  "fwWnrCr_CSC_LV", // this is the corresponding Device Unit Type
  makeDynString(".status"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("LvForHv_Cr", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("LvForHv_Cr", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "LvForHv_Cr", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR

  
  // LV for HV Wiener Channel
  majority_addDevice("LvForHv_Ch", // this defines the internal name of the device for the majority
  "fwWnrCh_CSC_LV", // this is the corresponding Device Unit Type
  makeDynString(".status"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("LvForHv_Ch", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("LvForHv_Ch", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "LvForHv_Ch", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureAtlasPSU(string topNode) {
  // Atlas PSU branch
  majority_addDevice("AtlasPSU_Branch", // this defines the internal name of the device for the majority
  "FwElmbPSUBranch", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("AtlasPSU_Branch", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("AtlasPSU_Branch", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "AtlasPSU_Branch", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureHVPrimaries(string topNode) {
  // HV Primary supplies
  majority_addDevice("HV_Primary", // this defines the internal name of the device for the majority
  "HV_PR", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "standby", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("HV_Primary", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_Primary", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_Primary", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "HV_Primary", makeDynFloat(100, 100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureME11Hv(string topNode) {
  // ME1/1 HV
  majority_addDevice("HV_ME11", // this defines the internal name of the device for the majority
  "FwCaenChannel", // this is the corresponding Device Unit Type
  makeDynString(".fsm.currentState"), // define the datapoint elements you need to connect
  makeDynString("on", "standby", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("HV_ME11", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("HV_ME11", "standby", makeDynString("_Window","FwStateAttention1","yellow","yellow","yellow"));    
  majority_addColors("HV_ME11", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "HV_ME11", makeDynFloat(95, 95, 5)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureGas(string topNode) {
  //GAS - top (global) device only
  majority_addDevice("Gas", // this defines the internal name of the device for the majority
  "fwGasSystem_CSC_GAS", // this is the corresponding Device Unit Type
  makeDynString(".status"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("Gas", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("Gas", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "Gas", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}

void configureCooling(string topNode) {
  //GAS - top (global) device only
  majority_addDevice("Cooling", // this defines the internal name of the device for the majority
  "fwCooling_CSC_COOLING", // this is the corresponding Device Unit Type
  makeDynString(".status"), // define the datapoint elements you need to connect
  makeDynString("on", "error"), // these are the basic device states for this device
  1 // this is the weight for this device (default = 1). Your state counts must be between 0 and the weight. This is useful for device units that group many channels
  );
 
  // For each device and each state define the colors to be used in the interface. Standard colors are defined for on and error states, but can be customized              
  majority_addColors("Cooling", "on", majority_getStandardColorsOn() ); // majority_getStandardColorsOn() uses a lighter green to differentiate when the percentage = 100%. However if you set the threshold (see below) to 100, use majority_getStandardColorsPhysics
  majority_addColors("Cooling", "error", majority_getStandardColorsError() );    

  majority_addPercentages(topNode, "Cooling", makeDynFloat(100, 0)); // here you define the thresholds for the percentages: in this case we have 95% for ON and 5% for ERROR
}
