V 10
2
LANG:1 27 fwElmbAiConfigConfiguration
LANG:5 8 (NoName)
PANEL,-1 -1 589 592 N "_3DFace" 2
"$sDpName"
"$sElmbLabels"
E "main()
{
	int i;
}" 0
 E E E 1 -1 -1 0  0 0
""0  1
E "
// ************************************************************************************
// Function:		modAllowCreate
//
// Description:	Checks various flags to see if creation of sensor with current settings
//							is valid or not.
//
// Returns:			None
// ************************************************************************************
void modAllowCreate()
{
// Local Variables
// ---------------
// None

// Executable Code
// ---------------
	if (chkChannelsAvailable.state(0) && chkSensorNameValid.state(0)) {
		cmdApply.enabled = true;
		cmdOK.enabled = true;
	} else {
		cmdApply.enabled = false;
		cmdOK.enabled = false;
	}
		
	// Return to calling routine
	return;
}

// ************************************************************************************
// Function:		modCheckValidDP
//
// Description:	Check ELMB name given is valid and if so, returns the fully valid DP
//							name in the first argument
//
// Returns:			true if name valid
//							false otherwise
// ************************************************************************************
bool modCheckValidDP(	string &argsDpName,
											string argsElmb = \"\")
{
// Local Variables
// ---------------
	bool bValid = false;
	
	dyn_string dsTemp = strsplit($sElmbLabels, \"|\");

// Executable Code
// ---------------
	if (argsElmb == \"\")
		argsElmb = dsTemp[1];

	// Check DP given is valid
	if (dpTypeName($sDpName) == ELMB_AI_CONFIG_TYPE_NAME) {
		argsDpName = $sDpName;
		bValid = true;
	} else if (dpTypeName($sDpName) == ELMB_TYPE_NAME) {
		argsDpName = $sDpName + fwDevice_HIERARCHY_SEPARATOR + ELMB_AI_CONFIG_NAME;
		bValid = true;
	} else if (dpTypeName($sDpName) == ELMB_CAN_BUS_TYPE_NAME) {
		argsDpName = $sDpName + fwDevice_HIERARCHY_SEPARATOR + argsElmb + fwDevice_HIERARCHY_SEPARATOR + ELMB_AI_CONFIG_NAME;
		bValid = true;
	} else {
 		ChildPanelOnCentral(\"vision/MessageInfo1\", \"Error: DP parent\", 
		                    makeDynString(\"Unknown parent DP-Type passed to this panel!!\"));
	}

	// Return to calling routine
	return (bValid);
}

// ************************************************************************************
// Function:		modUpdateParameterTable
//
// Description:	Updates table showing values to be applied to the parameter values for
//							the sensor
//
// Returns:			None
// ************************************************************************************
void modUpdateParameterTable(	string argsParameter,
															string argsParamDescription)
{
// Local Variables
// ---------------
	int i;
	
	string sDescription;
	
	dyn_string dsDefaultParameters;
	dyn_string dsDefaultParameterDescriptions;
	dyn_string dsTemp;

// Executable Code
// ---------------
  // Clear table contents and then fill with the right parameters:
  tblParameters.deleteAllLines();
  
	// Check if parameters exist
	if (argsParameter != ELMB_NO_INFO) {
		// Get information from the parameters given
		fwGeneral_stringToDynString(argsParameter, dsDefaultParameters);
		fwGeneral_stringToDynString(argsParamDescription, dsDefaultParameterDescriptions, \"|\", false);
  
		for (i = 1; i <= dynlen(dsDefaultParameters); i++) {
			if (dynlen(dsDefaultParameterDescriptions) < i || dsDefaultParameterDescriptions[i] == \"\")
				sDescription = \"%x\" + i;
			else
				sDescription = dsDefaultParameterDescriptions[i];

			tblParameters.appendLine(\"parameter\", \"%x\" + i, 
			                         \"description\", sDescription,
			                         \"value\", dsDefaultParameters[i]);
		}
	}

	// Return to calling routine
	return;
}

// ************************************************************************************
// Function:		modUpdateAvailableChannels
//
// Description:	Updates combo box for first channel selection with available channels.
//
// Returns:			dyn_string if available channels
// ************************************************************************************
dyn_string modUpdateAvailableChannels(string argsDpName,
																			string argsPDOdp,
																			string &argsChannel)
{
// Local Variables
// ---------------
	bool bFilter;
	
	int i;
	int iPos = 0;
	
	dyn_string dsAvailableChannels;
	dyn_string dsExceptionInfo;

// Executable Code
// ---------------
	// Check whether to filter channels or not
	bFilter = chkShowAvailableOnly.state(0);
	
	// Get list of available channels
	fwElmb_channelFilter(argsDpName,
						           ELMB_AI_TYPE_NAME,
				  	 	         dsAvailableChannels,
			  		 	         dsExceptionInfo,
			  		 	         argsPDOdp,
			  		 	         bFilter);
				  		 	         
	// Check for errors
	if (dynlen(dsExceptionInfo) > 0) {
		fwExceptionHandling_display(dsExceptionInfo);
		return;
	}
	
	// Populate list of available channels
	cmbChannelSelector.items = dsAvailableChannels;
		
	// Initialise position of any given channel
	if (strlen(argsChannel) > 0)
		iPos = dynContains(dsAvailableChannels, argsChannel);
	if (iPos <= 0)
		iPos = 1;
	cmbChannelSelector.selectedPos = iPos;
	argsChannel = cmbChannelSelector.selectedText;

	// Return to calling routine
	return (dsAvailableChannels);
}

// ************************************************************************************
// Function:		modUpdateHowManySensors
//
// Description:	Updates fields relevant to the number of sensors that can be created.
//							It checks for the number of consecutive channels available from the one
//							currently selected.
//
// Returns:			None
// ************************************************************************************
void modUpdateHowManySensors(string argsChannel)
{
// Local Variables
// ---------------
	int i;
	int iChannelsPerSensor;
	int iPosSelectedChannel;
	int iMaxChannels = 1;
	int iMaxSensors;
	int iChannel;
	int iTemp;
	
	string sTemp;
	
	dyn_string dsAvailableChannels;
	dyn_string dsIds;

// Executable Code
// ---------------
	// Check if any channels available
	dsAvailableChannels = cmbChannelSelector.items;
	if (dynlen(dsAvailableChannels) == 1) {
		// This also covers special cases of non-multiplexed PDOs and multiplexed
		// PDOs where the multiblex byte value is fixed
		lblMessage.visible = false;
		chkChannelsAvailable.state(0) = true;
		spnAiHowMany.sbMinimum = 1;
		spnAiHowMany.text = \"1\";
		spnAiHowMany.enabled = false;
		lstChannels.items = dsAvailableChannels[1];
		return;
	} else if (dynlen(dsAvailableChannels) > 1) {
		lblMessage.visible = false;
		spnAiHowMany.sbMinimum = 1;
	} else {
		lblMessage.visible = true;
		lblChannelSelector.visible = false;
		chkChannelsAvailable.state(0) = false;
		spnAiHowMany.sbMinimum = 0;
		spnAiHowMany.text = \"0\";
		spnAiHowMany.enabled = false;
		return;
	}
	
	// Get number of channels used by the current sensor
	sTemp = lblChannelCounter.text;
	sscanf(sTemp, \"%d\", iChannelsPerSensor);
	
	// Check if a channel has already been selected, and get the number
	if (argsChannel == \"\") {
		iPosSelectedChannel = 1;
	} else {
		iPosSelectedChannel = dynContains(dsAvailableChannels, argsChannel);
	}
	iChannel = dsAvailableChannels[iPosSelectedChannel];
	
	// If we've gotten this far, we know there are at least two channels available
	// (though these may not be consecutive channels)
	for (i = iPosSelectedChannel; i < dynlen(dsAvailableChannels); i++) {
		iTemp = dsAvailableChannels[i + 1];
		iChannel++;
		if (iTemp == iChannel)
			iMaxChannels++;
		else
			break;
	}

	// Calculate the number of sensors that can be created
	iMaxSensors = floor(iMaxChannels / iChannelsPerSensor);	
	
	// Check value displayed, and limit it if necessary
	if (iMaxSensors > 0) {
		sTemp = spnAiHowMany.text;
		sscanf(sTemp, \"%d\", iTemp);
		if (iTemp > iMaxSensors) {
			sprintf(sTemp, \"%d\", iMaxSensors);
			spnAiHowMany.text = sTemp;
		}
	
		// Set other controls
		spnAiHowMany.sbMaximum = iMaxSensors;
		spnAiHowMany.enabled = true;
		chkChannelsAvailable.state(0) = true;
		dynClear(dsIds);
		sscanf(argsChannel, \"%d\", iChannel);
		for (i = 0; i < iChannelsPerSensor; i++) {
			sprintf(sTemp, \"%d\", iChannel + i);
			dynAppend(dsIds, sTemp);
		}
		lstChannels.items = dsIds;
	} else {
		lstChannels.deleteAllItems();
 		ChildPanelOnCentral(\"vision/MessageInfo1\",
 												\"Error: Invalid channel number\", 
		                    makeDynString(\"Sensor cannot be created since there are not \" + iChannelsPerSensor + \"\\nconsecutive channels free to be used!!\"));
		chkChannelsAvailable.state(0) = false;
		spnAiHowMany.sbMinimum = 0;
		spnAiHowMany.text = \"0\";
		spnAiHowMany.enabled = false;
	}

	// Return to calling routine
	return;
}

// ************************************************************************************
// Function:		pnlUpdateForSensorsOnChange
//
// Description:	Updates all fields in the panel. This is mainly used on initialisation
//							and when a different sensor type is selected from the combo box
//
// Returns:			None
// ************************************************************************************
void pnlUpdateForSensorsOnChange( string argsChannel = \"\",
																	string argsElmb = \"\")
{
// Local Variables
// ---------------
	bool bIsStandard;
	bool bIsRaw;
	bool bMuxAll;
	bool bMuxed;
	
	int i;
	int iPos;
	int iCount = 0;
	
	string sDpName;
  string sSensorType;
  string sSensorName;
  string sParameter;
  string sFctTemplate;
  string sPrefix;
	string sParamDescription;
	string sTruncatedFormula;
	string sPDOdp;
	string sProfile;
	
	dyn_bool dbIsStandard;
	dyn_bool dbIsRaw;
	
	dyn_string dsAvailableChannels;
	dyn_string dsSensorTypes;
	dyn_string dsFctTemplate;
	dyn_string dsParameters;
	dyn_string dsParamDescriptions;
	dyn_string dsPrefixes;
	dyn_string dsPDOdps;
	dyn_string dsTemp;

// Executable Code
// ---------------
	// Attempt to get a valid DP name from the ELMB name given
	if (!modCheckValidDP(sDpName, argsElmb))
		return;
	
	// Get the selected sensor
	iPos = cmbSensorType.selectedPos();
	
	// Get information about all sensors
	dpGet(ELMB_SENSOR_INFO_NAME + \".types\", dsSensorTypes,
        ELMB_SENSOR_INFO_NAME + \".functions\", dsFctTemplate,
        ELMB_SENSOR_INFO_NAME + \".parameters\", dsParameters,
        ELMB_SENSOR_INFO_NAME + \".parameterDescriptions\", dsParamDescriptions,
        ELMB_SENSOR_INFO_NAME + \".prefix\", dsPrefixes,
        ELMB_SENSOR_INFO_NAME + \".isStandard\", dbIsStandard,
        ELMB_SENSOR_INFO_NAME + \".isRaw\", dbIsRaw,
        ELMB_SENSOR_INFO_NAME + \".pdoDp\", dsPDOdps);
        
  // Get information specific to the selected sensor
  sSensorType = dsSensorTypes[iPos];
  sFctTemplate = dsFctTemplate[iPos];
  sParameter = dsParameters[iPos];
	sParamDescription = dsParamDescriptions[iPos];
  sPrefix = dsPrefixes[iPos];
  bIsStandard = dbIsStandard[iPos];
  bIsRaw = dbIsRaw[iPos];
  sPDOdp = dsPDOdps[iPos];
		
	// Get information about the PDO used
	if (sPDOdp == ELMB_NO_INFO) {
		// Default analog input used
		bMuxed = true;
		bMuxAll = true;
	} else {
		dpGet(sPDOdp + \".profile\", sProfile,
					sPDOdp + \".mux.all\", bMuxAll);
					
		if ((sProfile == \"404\") || (sProfile == \"LMB\")) {
			bMuxed = true;
		} else {
			bMuxed = false;
			bMuxAll = false;
		}
	}
		
	// If sensor is a standard type, do not allow edits or deletions
	if (bIsStandard) {
		setValue(\"cmdSensorType\", \"enableItem\", \"1\", false);
		setValue(\"cmdSensorType\", \"enableItem\", \"2\", false);
	} else {
		setValue(\"cmdSensorType\", \"enableItem\", \"1\", true);
		setValue(\"cmdSensorType\", \"enableItem\", \"2\", true);
	}

	// How many channels does our sensor use? (only applicable to non-raw sensors)
	if (!bIsRaw) {
		for (i = 1; i <= ELMB_MAX_CHANNEL; i++) {
			if (patternMatch(\"*%c\" + i + \"*\", sFctTemplate))
				iCount++;
		}
	} else {
		iCount = 1;
	}
	
	// Enter the number of channels used into the correct field
	lblChannelCounter.text = iCount; 

	// Display the function (if sensor is raw, just indicate the channel value is used)
	if (bIsRaw) {
		lblEquationNote.text = \"\";
		lblEquation.text = \"%c1\";
	} else if (strlen(sFctTemplate) > 95) {
		sTruncatedFormula = substr(sFctTemplate, 0, 95) + \"...\";
	  lblEquation.text = sTruncatedFormula;
		lblEquationNote.text = \"Formula is too long to show all of it. It has been truncated (indicated by '...')\";
	} else {
		lblEquationNote.text = \"\";
	  lblEquation.text = sFctTemplate;
	}
  
	// Set the prefix field
	txtUserName.text = sPrefix;
	
	// Set other controls
  chkIsRaw.state(0) = bIsRaw;
	chkIsMultiplexed.state(0) = bMuxed;
	chkMultiplexedAll.state(0) = bMuxAll;
	if (bIsRaw) {
		txtUserName.enabled = false;
		frmSensorPrefix.enabled = false;
		if (bMuxed && bMuxAll) {
			chkAppendChannelNumber.state(0) = true;
			chkAppendChannelNumber.enabled = false;
			spnDigitsForChannel.sbMinimum = 1;
			spnDigitsForChannel.text = \"1\";
			spnDigitsForChannel.enabled = false;
			lblChannelSelector.visible = true;
			cmbChannelSelector.visible = true;
		} else {
			chkAppendChannelNumber.state(0) = false;
			chkAppendChannelNumber.enabled = false;
			spnDigitsForChannel.sbMinimum = 0;
			spnDigitsForChannel.text = \"0\";
			spnDigitsForChannel.enabled = false;
			lblChannelSelector.visible = false;
			cmbChannelSelector.visible = false;
		}
		Border1.enabled = false;
	} else {
		txtUserName.enabled = true;
		frmSensorPrefix.enabled = true;
		if (bMuxed && bMuxAll) {
			chkAppendChannelNumber.enabled = true;
			spnDigitsForChannel.sbMinimum = 1;
			spnDigitsForChannel.text = \"1\";
			spnDigitsForChannel.enabled = true;
			lblChannelSelector.visible = true;
			cmbChannelSelector.visible = true;
		} else {
			chkAppendChannelNumber.state(0) = false;
			chkAppendChannelNumber.enabled = false;
			spnDigitsForChannel.sbMinimum = 0;
			spnDigitsForChannel.text = \"0\";
			spnDigitsForChannel.enabled = false;
			lblChannelSelector.visible = false;
			cmbChannelSelector.visible = false;
		}
		Border1.enabled = true;
	}
	
	// Update the table showing the parameters
	modUpdateParameterTable(sParameter, sParamDescription);

	// Get all available channels and update combo box (within function)
	dsAvailableChannels = modUpdateAvailableChannels(sDpName, sPDOdp, argsChannel);

	// Update controls, checking the correct number of consecutive channels exist
	modUpdateHowManySensors(argsChannel);
	
	// Update sensor name
	modUpdateSensorName();
	modAllowCreate();
	
	// Return to calling routine
	return;
}

// ************************************************************************************
// Function:		modUpdateSensorName
//
// Description:	Creates name of sensor to be created using prefix given and channel
//							numbers that will be used
//
// Returns:			None
// ************************************************************************************
void modUpdateSensorName()
{
// Local Variables
// ---------------
	string sSensorName;

// Executable Code
// ---------------
	// Get name of first sensor that would be created
	if (pnlGetAnalogName(sSensorName)) {
		if (chkAppendChannelNumber.state(0))
			lblSensorName.text = \"First sensor will be \" + sSensorName;
		else
			lblSensorName.text = \"Sensor name will be \" + sSensorName;
		chkSensorNameValid.state(0) = true;
	} else {
		lblSensorName.text = \"Sensor prefix is invalid\";
		chkSensorNameValid.state(0) = false;
	}

	// Return to calling routine
	return;
}

// ************************************************************************************
// Function:		pnlGetAnalogName
//
// Description:	Creates name of sensor to be created using prefix given and channel
//							numbers that will be used
//
// Returns:			true if name found
//							false otherwise
// ************************************************************************************
bool pnlGetAnalogName(string &sSensorName)
{
// Local Variables
// ---------------
	bool bValid = false;
	
	int i;
	int iTemp;
	
	string sTemp;
	string sFormat;
	string sDigits;
	
	dyn_string dsIds = lstChannels.items;
	dyn_string dsExceptionInfo;
	
// Executable Code
// ---------------
	// Get the prefix given
	sSensorName = txtUserName.text;
	
	// Check there is some text given
	if (strlen(sSensorName) > 0) {
		// Check if raw value sensor
		if (!chkIsRaw.state(0)) {
	
			bValid = fwElmb_checkSensorPrefix(sSensorName);
			
			if (!bValid) {
				fwException_raise(dsExceptionInfo,
													\"ERROR\",
													\"'\" + sSensorName + \"' is reserved for a Raw Value Sensor and cannot be used\",
													\"\");
				fwExceptionHandling_display(dsExceptionInfo);
				txtUserName.text = \"\";
				sSensorName = \"\";
			}
		} else {
			bValid = true;
		}
		
		if (bValid) {
	
			// Get the minimum number of digits to use in the channel number
			sDigits = spnDigitsForChannel.text;
			sFormat = \"%0\" + sDigits + \"d\";
		
			// Append channel name if required
			if (chkAppendChannelNumber.state(0)) {
				for (i = 1; i <= dynlen(dsIds); i++) {
					iTemp = dsIds[i];
					sprintf(sTemp, sFormat, iTemp);
					sSensorName += ((i > 1) ? \"_\" : \"\") + sTemp;
				}
			}
		}
	}

	// Return to calling routine
	return (bValid);
}


// ************************************************************************************
// Function:		modCreateAiChannels
//
// Description:	Creates sensors using information specified in panel
//
// Returns:			None
// ************************************************************************************
void modCreateAiChannels()
{
// Local Variables
// ---------------
	bool bIsRunning;
	bool bIsOk = true;
	bool bDefaultOPCAddressing;
	
	const int MAX_ERRORS = 5;
	
	int numElmbs;
	int iErr;
	int iDriverNumber;
	int i, ii, k = 0;
	int iPos;
	int iHowMany;
	int iTemp;
	int iErrorCount = 0;
	
	float fPercentage;
	float fAll, fCompleted;
	
	string sOpcItem;
	string sBusName;
	string sElmbName;
	string sServerName;
	string sSensorName;
	string sChannelName;
	string sComment;
	string sFct;
	string sSensorType;
	string sConfigName;
	string sSubConfig;
	string sConfigType;
	string sSubDpName;
	string nodeName;
	string sFctTemplate;
	string sParameter;
	string sNextChannel;
	string sElmbOpcItem;
	string sTemp;
	string sFirstChannel;
	string sDpname;
	string sMessage;
	string sPDOdp;

	dyn_float df;

	dyn_string dsIds;
	dyn_string dsExceptionInfo;
	dyn_string dsTemp;
	dyn_string dsAddressParameters;
	dyn_string ds;
	dyn_string dsOpcItems;
	dyn_string dsFunctionTemplate;
	dyn_string dsParameters;
	dyn_string dsDefaultParameters;
	dyn_string dsAvailableIds;
	dyn_string dynTemp;
	dyn_string dsTempIds;
	
	dyn_anytype daLine;
	
// Executable Code
// ---------------
	// Check correct driver is running
	bIsRunning = fwElmbUser_checkDefaultDriver(iDriverNumber, dsExceptionInfo);
	if (dynlen(dsExceptionInfo) > 0) {
		fwExceptionHandling_display(dsExceptionInfo);
		return;
	} else if (!bIsRunning) {
		// Display panel indicating what the problem is and how to fix it
		ChildPanelOnCentralReturn(\"fwElmb/fwElmbDriverMessage.pnl\", 
															\"Warning\",
															makeDynString(\"$drvNum:\" + iDriverNumber),
															df, ds);
		return;
	}
	
	// Initialise some of the local variables
	dynTemp = strsplit($sElmbLabels,\"|\");
	numElmbs = dynlen(dynTemp);
	
	if (!pnlGetAnalogName(sSensorName)) {
 		ChildPanelOnCentral(\"vision/MessageInfo1\",
 												\"Error: Invalid Sensor Prefix\",
		                    makeDynString(\"Sensor must be given a prefix name\"));
		return;
	}	

	// Get the parameters from the table in the panel
	for (i = 0; i < tblParameters.lineCount; i++) {
		daLine = tblParameters.getLineN(i);
		sTemp = daLine[1];
		sTemp = strltrim(sTemp, \"%x\");
		sscanf(sTemp, \"%d\", iTemp);
		dsDefaultParameters[iTemp] = daLine[3];
	}
	
	// Get all required information from panel controls
	bDefaultOPCAddressing = chkOpcAddressing.state(0);
	sSensorType = cmbSensorType.text;
	iHowMany = spnAiHowMany.text;
	iPos = cmbSensorType.selectedPos;
	sComment = txtComment.text;
	sFirstChannel = cmbChannelSelector.text;
	dsAvailableIds = cmbChannelSelector.items;
	iPos = cmbSensorType.selectedPos();
	
	// Get information about PDO DP used
	dpGet(ELMB_SENSOR_INFO_NAME + \".pdoDp\", dsTemp);
	sPDOdp = dsTemp[iPos];
	
	fAll = numElmbs * iHowMany;
	fCompleted = 0.0;
	fPercentage = 0.0;

	// Start progress bar to indicate system is busy
	fwOpenProgressBar(\"Create Sensor\", \"In progress. Please wait...\", 2);
	
	// Loop through all ELMBs
	for (ii = 1; ii <= dynlen(dynTemp); ii++) {
	
		// Check ELMB exists
		if (!modCheckValidDP(sDpname, dynTemp[ii])) {
	 		ChildPanelOnCentral(\"vision/MessageInfo1\",
	 												\"Error: Invalid Device Name\",
			                    makeDynString(\"Datapoint is invalid\"));
			return;
		}

		// Remove system name if it has been given
		sSubDpName = substr($sDpName, strpos($sDpName, \":\") + 1);

		// Get Bus and ELMB name
		dsTemp = strsplit(sSubDpName, fwDevice_HIERARCHY_SEPARATOR);
		sBusName = dsTemp[2];
		sElmbName = dynTemp[ii];
		
		// Reset first channel number for each ELMB
		dsAvailableIds = modUpdateAvailableChannels(sDpname, sPDOdp, sFirstChannel);
		modUpdateHowManySensors(sFirstChannel);
		pnlGetAnalogName(sSensorName);

		iErrorCount = 0;
		for (k = 1; (k <= iHowMany) && (iErrorCount < MAX_ERRORS); k++) {
			dsIds = lstChannels.items;
			sMessage = \"Creating \" + sElmbName + fwDevice_HIERARCHY_SEPARATOR +
									ELMB_AI_CONFIG_NAME + fwDevice_HIERARCHY_SEPARATOR +
									sSensorName;
			fPercentage = fCompleted * 100.0 / fAll;
			fwShowProgressBar(sMessage, fPercentage);

			fwElmbUser_createSensor(sSensorName, 
														  sBusName, 
														  sElmbName,
														  sComment, 
														  dsIds, 
														  sSensorType,
														  dsDefaultParameters,
														  bDefaultOPCAddressing,
														  dsExceptionInfo);
														  
			// Check for any errors
			if (dynlen(dsExceptionInfo) > 0)
				iErrorCount++;
			fCompleted += 1.0;
			
			// If there are several ELMB's the first channel every loop is the same
			if (k != iHowMany) {
				// Calculate the next ELMB channel that will be used!
				// Must be careful since we could find a channel that is not
				// in the list of available channels.
				// What about this:
				sNextChannel = dsAvailableIds[dynContains(dsAvailableIds, dsIds[dynlen(dsIds)]) + 1];
	
				dsAvailableIds = modUpdateAvailableChannels(sDpname, sPDOdp, sNextChannel);
				modUpdateHowManySensors(sNextChannel);
			}
			pnlGetAnalogName(sSensorName);
		}//end of loop over k (for Sensors)
		
	}// end loop ii (for ELMBs)

	sNextChannel = \"\";
	dsAvailableIds = modUpdateAvailableChannels(sDpname, sPDOdp, sNextChannel);
	modUpdateHowManySensors(sNextChannel);
	modUpdateSensorName();
	modAllowCreate();
	
	if (dynlen(dsExceptionInfo) > 0) {
		fwCloseProgressBar(\"Sensor creation encountered errors\");
		fwExceptionHandling_display(dsExceptionInfo);
	} else {
		fwCloseProgressBar(\"Sensor creation completed successfully\");
	}	
	
	// Return to calling routine
	return;
}
" 0
 2
"CBRef" "1"
"EClose" "main()
{
	int i;
}" 0

""
DISPLAY_LAYER, 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
LAYER, 0 
1
LANG:1 6 Layer1
30 5
"frmSensorType"
""
1 11 101 E E E 1 E 1 E N "_3DText" E N "_Transparent" E E
 E E
4 0 0 0 0 0
E E E
1
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 11 51 311 101
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 11 Sensor Type
30 6
"frmSensorPrefix"
""
1 330 140 E E E 1 E 1 E N "_3DText" E N "_Transparent" E E
 E E
5 0 0 0 0 0
E E E
1
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 330 51 580 140
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 18 Sensor Prefix Name
2 7
"lblComment"
""
1 27 440 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
5 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 29 442 85 459
0 2 0 "0s" 0 0 0 192 0 0  29 442 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 7 Comment
30 13
"frmConfiguration"
""
1 11 499 E E E 1 E 1 E N "_3DText" E N "_Transparent" E E
 E E
11 0 0 0 0 0
E E E
1
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 11 150 580 500
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 13 Configuration
2 14
"lblTitle"
""
1 15 88 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
12 0 0 0 0 0
E E E
0
2
LANG:1 0 
LANG:5 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 17 13 288 37
0 2 0 "0s" 0 0 0 64 0 0  17 13 1
2
LANG:1 84 -*-Arial-*-r-normal-*-21-*-100-100-*-*-iso8859-1|-21,0,0,0,404,0,0,0,0,0,0,0,0,Arial
LANG:5 107 -microsoft windows-Arial-normal-r-normal-*-*-180-100-100-*-*-iso8859-1|-21,0,0,0,400,0,0,0,0,3,2,1,34,Arial
0 ""
2
LANG:1 26 Create Analog Input Sensor
LANG:5 16 Create Elmb Node
30 15
"frmOPCAddressing"
""
1 10 549 E E E 1 E 1 E N "_3DText" E N "_Transparent" E E
 E E
13 0 0 0 0 0
E E E
1
2
LANG:1 0 
LANG:5 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 10 507 580 549
2
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
LANG:5 107 -microsoft windows-Arial-normal-r-normal-*-*-120-100-100-*-*-iso8859-1|-13,0,0,0,400,0,0,0,0,3,2,1,34,Arial
0 ""
2
LANG:1 0 
LANG:5 0 
2 16
"lblChannelSelector"
""
1 34 442 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
14 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 35 405 155 418
0 2 0 "0s" 0 0 0 64 0 0  35 405 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 19 First ELMB Channel:
2 18
"lblChannelsUsed"
""
1 25 210 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
16 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 27 212 358 228
0 2 0 "0s" 0 0 0 64 0 0  27 212 1
1
LANG:1 87 -*-Arial-bold-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,697,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 49 Number of ELMB channels used by this sensor type:
2 30
"lblApplyChanges"
""
1 25 321 E E E 1 E 1 E N {255,0,0} E N "_Transparent" E E
 E E
28 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 27 323 278 360
0 2 0 "0s" 0 0 0 64 0 0  27 323 2
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 40 For changes in the table to be permanent
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 39 you must press the Apply Changes button
30 31
"frmChannelInformation"
""
1 25 440 E E E 1 E 1 E N "_3DText" E N "_Transparent" E E
 E E
29 0 0 0 0 0
E E E
1
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 25 368 560 440
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 0 
2 35
"lblHowManySensors"
""
1 220 455 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
31 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 222 405 341 424
0 2 0 "0s" 0 0 0 64 0 0  222 405 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 17 How many sensors?
2 36
"lblMessage"
""
1 30 400 E E E 1 E 1 E N {255,0,0} E N "_Transparent" E E
 E E
32 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 32 402 158 421
0 2 0 "0s" 0 0 0 64 0 0  32 402 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 21 No channels available
2 37
"lblSensorFormula"
""
1 25 168 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
32 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 27 170 123 186
0 2 0 "0s" 0 0 0 64 0 0  27 170 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 15 Sensor Formula:
2 38
"lblEquation"
""
1 25 188 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
33 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 27 190 563 206
0 2 0 "0s" 0 0 0 64 0 0  27 190 1
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 0 
2 39
"lblChannelCounter"
""
1 365 208 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
34 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 367 210 393 229
1 2 0 "0s" 0 0 0 65 0 0  367 210 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 0 
2 42
"lblEquationNote"
""
1 130 168 E E E 1 E 1 E N {255,0,0} E N "_Transparent" E E
 E E
37 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 132 170 568 186
0 2 0 "0s" 0 0 0 64 0 0  132 170 1
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 0 
2 45
"lblDigitsForChannel"
""
1 400 448 E E E 1 E 1 E N {0,0,0} E N "_Transparent" E E
 E E
39 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 402 405 508 421
0 2 0 "0s" 0 0 0 64 0 0  402 405 1
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 19 Digits for channel:
2 47
"lblSensorName"
""
1 340 90 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
40 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 0 1 E U  0 E 342 92 558 108
0 2 0 "0s" 0 0 0 64 0 0  342 92 1
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
1
LANG:1 0 
1 60 0 "" 0
0
22 1
"cmbSensorType"
""
1 22 66 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
2 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 20 64 174 91
0

"main()
{
// Local Variables
// ---------------
	dyn_string dsSensorTypes;
	
// Executable Code
// ---------------
	// Get all sensor types defined in this system
	dpGet(ELMB_SENSOR_INFO_NAME + \".types\", dsSensorTypes);
	
	// Display the information in the combo box
	this.items = dsSensorTypes;
	
	// Select the first entry in the list
	this.selectedPos = 1;
	
	// Update all fields in the panel for this sensor
	pnlUpdateForSensorsOnChange();
	
	// Return to calling routine
	return;
}" 0

"main()
{
	// Call function to update all fields for new selected sensor
	pnlUpdateForSensorsOnChange();
}" 0

E
 0 0
14 3
"txtUserName"
""
1 340 67 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
4 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 338 65 552 92
3 "0s" 0 0 0 0 0 -1  E E "main()
{
	// Update name of first sensor to be created
	modUpdateSensorName();
	modAllowCreate();
}" 0

14 19
"txtComment"
""
1 27 460 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
17 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 25 458 564 485
3 "0s" 0 0 0 0 0 -1  E E E
20 21
"chkOpcAddressing"
""
1 25 520 E E E 1 E 1 E N "_3DText" E N "_3DFace" E E
 E E
19 0 0 0 0 0
E E E
0
2
LANG:1 0 
LANG:5 0 

0
2
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
LANG:5 107 -microsoft windows-Arial-normal-r-normal-*-*-120-100-100-*-*-iso8859-1|-13,0,0,0,400,0,0,0,0,3,2,1,34,Arial
0 ""
 23 518 220 541
1
T 
2
LANG:1 23 Default OPC addressing?
LANG:5 23 Default OPC addressing?

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
E"main(int button, bool state)
{
// Local Variables
// ---------------
	dyn_float df;
	dyn_string ds;

// Executable Code
// ---------------
	if (!state) {
		ChildPanelOnCentralReturn(\"vision/MessageInfo\",
															\"Question\",
															makeDynString(\"Unselecting this option you'll have to address\\nyour devices by hand.\\nAre you sure you want to do it?\", \"Yes\", \"No\"),
															df, ds);
		if (df[1] != 1.0)
			this.state(button) = true;
	}
	
	// Return to calling routine
	return;
}" 0
17 25
"lstChannels"
""
1 290 10 E E E 1 E 0 E N "_WindowText" E N "_Window" E E
 E E
23 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 96 -*-Courier New-*-r-normal-*-12-*-100-100-*-*-iso8859-1|-12,0,0,0,404,0,0,0,0,0,0,0,0,Courier New
0 ""
 288 8 352 42
0

E
E
E

0 0
22 26
"cmbChannelSelector"
""
1 160 403 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
24 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 158 401 214 428
0

E
"main()
{
// Local Variables
// ---------------
	string sChannel = this.text;
	
// Executable Code
// ---------------
	// Update fields relevant to first channel selected
	modUpdateHowManySensors(sChannel);
	
	// Update name of first sensor to be created
	modUpdateSensorName();
	modAllowCreate();
	
	// Return to calling routine
	return;
}" 0

E
 0 0
25 27
"tblParameters"
""
1 -1257 31 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
25 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 23 238 562 324
EE 1 0 1 3 1 "parameter" 8 1 0 "s" 1
LANG:1 9 Parameter
E
1
LANG:1 0 

100 "description" 29 1 1 "s" 1
LANG:1 11 Description
E
1
LANG:1 67 Click on the corresponding cell to change the parameter description

331 "value" 7 1 1 "s" 1
LANG:1 5 Value
E
1
LANG:1 44 Click on the cell to enter the default value

91 
26 26 "" 1 1
LANG:1 2 #1
8 30
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
0 2 0 1 7
1 0
13 29
"cmdApplyChanges"
""
1 451 328 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
27 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 449 326 562 363

T 
1
LANG:1 13 Apply Changes
"main()
{
// Local Variables
// ---------------
	int iLines;
	int i, j;
	int iSelectedSensorType = cmbSensorType.selectedPos;
	
	string sParameters;
	string sDescriptions;
	string sTemp;
	
	dyn_string dsParameters;
	dyn_string dsDescriptions;
	dyn_string dsAllParameters;
	dyn_string dsAllDescriptions;

	dyn_anytype daLine;

// Executable Code
// ---------------
	// Get information from 'SensorInfo' DP
	dpGet(ELMB_SENSOR_INFO_NAME + \".parameters\", dsAllParameters,
	      ELMB_SENSOR_INFO_NAME + \".parameterDescriptions\", dsAllDescriptions);

	// Get information from the table
	for (i = 0; i < tblParameters.lineCount; i++) {
		
		// Get the data from the current line
		daLine = tblParameters.getLineN(i);
		
		// Get the '%x' parameter number
		sTemp = daLine[1];
		sTemp = strltrim(sTemp, \"%x\");
		sscanf(sTemp, \"%d\", j);
		
		// Set information into local variable
		dsDescriptions[j] = daLine[2];
		dsParameters[j] = daLine[3];
		
		// Trim each value of any spaces
		dsDescriptions[j] = strltrim(dsDescriptions[j], \" \");
		dsDescriptions[j] = strrtrim(dsDescriptions[j], \" \");
		dsParameters[j] = strltrim(dsParameters[j], \" \");
		dsParameters[j] = strrtrim(dsParameters[j], \" \");
	}
	
	// Create strings of the parameters and descriptions
	fwGeneral_dynStringToString(dsDescriptions, sDescriptions);
	fwGeneral_dynStringToString(dsParameters, sParameters);
	
	// Set new information into the datapoint
	dsAllParameters[iSelectedSensorType] = sParameters;
	dsAllDescriptions[iSelectedSensorType] = sDescriptions;
	dpSet(ELMB_SENSOR_INFO_NAME + \".parameters\", dsAllParameters,
	      ELMB_SENSOR_INFO_NAME + \".parameterDescriptions\", dsAllDescriptions);
	
	// Return to calling routine
	return;
}" 0
 E E E
21 33
"spnAiHowMany"
""
1 350 403 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
29 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 348 401 392 428
0

E
E
E

N 1 64 1 1 1 1
26 43
"cmdSensorType"
""
1 192 66 E E E 1 E 1 E N "_3DText" E N "_3DFace" E E
 E E
38 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 190 64 289 92
 0 1
LANG:1 11 Sensor Type
"" 0 0 0 0 0
 3 1 1
LANG:1 13 Create New...
"cmdCreateNewSensorType" 0 0 0 0 0
 1 1
LANG:1 7 Edit...
"cmdEditSensorType" 0 0 0 0 0
 1 1
LANG:1 9 Delete...
"cmdDeleteSensorType" 0 0 0 0 0
 E "main(string id)
{
// Local Variables
// ---------------
	int iPos;
	
	string sSensorName;
	string sSensorPrefix;
	string sSensorFormula;
	
	dyn_bool dbIsRaw;
	dyn_bool dbIsStandard;
	
	dyn_float df;
	
	dyn_string ds;
	dyn_string dsExistingSensorTypes;
	dyn_string dsSensorPrefixes;
	dyn_string dsSensorFormulas;
	dyn_string dsParameters;
	dyn_string dsParamDescriptions;
	dyn_string dsPDOdps;

// Executable Code
// ---------------
	// Action whichever command has been selected
	if (id == \"cmdCreateNewSensorType\") {
	
		// Display panel allowing for a new sensor type to be created
		ChildPanelOnCentralModalReturn(	\"fwElmb/objects/fwElmbCreateNewSensorType.pnl\",
		                          			\"Create New Sensor Type\",
					                          makeDynString(\"\"),
					                          df, ds);

		// Refresh combo box of sensors existing (which will add any new one if created)                          
		dpGet(ELMB_SENSOR_INFO_NAME + \".types\", dsExistingSensorTypes);
		cmbSensorType.items = dsExistingSensorTypes;
		
	} else if (id == \"cmdEditSensorType\") {
	
		// Get which sensor is currently selected
		iPos = cmbSensorType.selectedPos;
	
		// Get all sensor information
		dpGet(ELMB_SENSOR_INFO_NAME + \".types\", dsExistingSensorTypes,
					ELMB_SENSOR_INFO_NAME + \".functions\", dsSensorFormulas,
					ELMB_SENSOR_INFO_NAME + \".prefix\", dsSensorPrefixes);
					
		// Get values to give to panel
		sSensorName = dsExistingSensorTypes[iPos];
		sSensorPrefix = dsSensorPrefixes[iPos];
		sSensorFormula = dsSensorFormulas[iPos];
					
		// Display panel allowing for a new sensor type to be created
		ChildPanelOnCentralModalReturn(	\"fwElmb/objects/fwElmbCreateNewSensorType.pnl\",
		                          			\"Edit Sensor Type\",
					                          makeDynString(\"$sSensorName:\" + sSensorName,
					                          							\"$sSensorPrefix:\" + sSensorPrefix,
					                          							\"$sSensorFormula:\" + sSensorFormula,
					                          							\"$bEdit:\" + true),
					                          df, ds);
	      
		// If sensor type has been edited, give message to check the variable descriptions
	  if (df[1] == 1.0) {
			ChildPanelOnCentralModal(	\"vision/MessageInfo1\",
																\"Information\",
																makeDynString(\"Please verify the parameter descriptions and modify\\nif necessary as they may now be incorrect.\\nNote: Existing sensors of this type are NOT updated\"));
		}
		                          
		// Update panel to reflect any changes made
		pnlUpdateForSensorsOnChange();
		                          
	} else if (id == \"cmdDeleteSensorType\") {
		// Get which sensor is currently selected
		iPos = cmbSensorType.selectedPos;
	
		// Get all sensor information
		dpGet(ELMB_SENSOR_INFO_NAME + \".types\", dsExistingSensorTypes,
					ELMB_SENSOR_INFO_NAME + \".functions\", dsSensorFormulas,
		      ELMB_SENSOR_INFO_NAME + \".parameters\", dsParameters,
		      ELMB_SENSOR_INFO_NAME + \".parameterDescriptions\", dsParamDescriptions,
		      ELMB_SENSOR_INFO_NAME + \".prefix\", dsSensorPrefixes,
		      ELMB_SENSOR_INFO_NAME + \".isStandard\", dbIsStandard,
		      ELMB_SENSOR_INFO_NAME + \".isRaw\", dbIsRaw,
		      ELMB_SENSOR_INFO_NAME + \".pdoDp\", dsPDOdps);
					
		// Get values to give to panel
		sSensorName = dsExistingSensorTypes[iPos];
		
		// Display panel for confirmation
		ChildPanelOnCentralModalReturn(	\"vision/MessageInfo\",
																		\"Confirm Deletion\",
																		makeDynString(\"Are you sure you wish to delete the\\nsensor type '\" + sSensorName + \"'?\\nExisting sensors will remain in the system\", \"OK\", \"Cancel\"),
																		df, ds);
		if (df[1] == 1.0) {
		  // Delete the sensor information
		  dynRemove(dsExistingSensorTypes, iPos);
		  dynRemove(dsSensorFormulas, iPos);
		  dynRemove(dsParameters, iPos);
		  dynRemove(dsParamDescriptions, iPos);
		  dynRemove(dsSensorPrefixes, iPos);
		  dynRemove(dbIsStandard, iPos);
		  dynRemove(dbIsRaw, iPos);
		  dynRemove(dsPDOdps, iPos);
		  
			// Set new information back into datapoint
			dpSet(ELMB_SENSOR_INFO_NAME + \".types\", dsExistingSensorTypes,
						ELMB_SENSOR_INFO_NAME + \".functions\", dsSensorFormulas,
		        ELMB_SENSOR_INFO_NAME + \".parameters\", dsParameters,
		        ELMB_SENSOR_INFO_NAME + \".parameterDescriptions\", dsParamDescriptions,
		        ELMB_SENSOR_INFO_NAME + \".prefix\", dsSensorPrefixes,
		        ELMB_SENSOR_INFO_NAME + \".isStandard\", dbIsStandard,
		        ELMB_SENSOR_INFO_NAME + \".isRaw\", dbIsRaw,
		        ELMB_SENSOR_INFO_NAME + \".pdoDp\", dsPDOdps);
		}

		// Refresh combo box of sensors existing (which will remove any that have been deleted)
		dpGet(ELMB_SENSOR_INFO_NAME + \".types\", dsExistingSensorTypes);
		cmbSensorType.items = dsExistingSensorTypes;
		cmbSensorType.selectedPos = 1;
		pnlUpdateForSensorsOnChange();
	}
	
	// Return to calling routine
	return;
}" 0
0 
21 46
"spnDigitsForChannel"
""
1 510 403 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
40 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 508 401 552 428
0

E
"main()
{
	// Update name of first sensor to be created
	modUpdateSensorName();
	modAllowCreate();
}" 0

E

N 1 3 1 1 1 1
20 49
"chkAppendChannelNumber"
""
1 340 110 E E E 1 E 1 E N "_3DText" E N "_3DFace" E E
 E E
42 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 338 108 522 132
1
T 
1
LANG:1 22 Append Channel Number?

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
E"main(int iButton, bool bNewState)
{
// Local Variables
// ---------------
// None

// Executable Code
// ---------------
	// Check the new state of the check button
	if (bNewState) {
		// Channel number should be appended. Ensure correct controls are enabled
		lblChannelSelector.text = \"First ELMB Channel:\";
		spnAiHowMany.enabled = true;
		spnDigitsForChannel.enabled = true;
		spnDigitsForChannel.sbMinimum = 1;
		spnDigitsForChannel.text = \"1\";
	} else {
		lblChannelSelector.text = \"ELMB Channel:\";
		spnAiHowMany.enabled = false;
		spnAiHowMany.text = \"1\";
		spnDigitsForChannel.enabled = false;
		spnDigitsForChannel.sbMinimum = 0;
		spnDigitsForChannel.text = \"0\";
	}
	
	// Update any other controls
	modUpdateSensorName();
	modAllowCreate();
	
	// Return to calling routine
	return;
}" 0
20 51
"chkIsRaw"
""
1 370 10 E E E 1 E 0 E N "_3DText" E N "_3DFace" E E
 E E
44 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 368 8 432 32
1
T 
1
LANG:1 7 Is Raw?

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
EE20 52
"chkIsMultiplexed"
""
1 460 10 E E E 1 E 0 E N "_3DText" E N "_3DFace" E E
 E E
45 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 458 8 552 32
1
T 
1
LANG:1 15 Is Multiplexed?

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
EE20 53
"chkMultiplexedAll"
""
1 460 30 E E E 1 E 0 E N "_3DText" E N "_3DFace" E E
 E E
46 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 458 28 562 52
1
T 
1
LANG:1 16 Multiplexed All?

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
EE20 54
"chkChannelsAvailable"
""
1 10 559 E E E 1 E 0 E N "_3DText" E N "_3DFace" E E
 E E
47 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 8 557 152 582
1
T 
1
LANG:1 23 Channels are available?

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
EE20 55
"chkSensorNameValid"
""
1 160 559 E E E 1 E 0 E N "_3DText" E N "_3DFace" E E
 E E
48 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 158 557 292 582
1
T 
1
LANG:1 21 Sensor name is valid?

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
EE13 56
"cmdOK"
""
1 350 559 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
49 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 348 557 422 584

T 
1
LANG:1 2 OK
"main()
{
	modCreateAiChannels();
	PanelOff();
	ModuleOff(\"NodeConfigurationModule\");
}" 0
 E E E
13 57
"cmdApply"
""
1 430 559 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
50 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 428 557 502 584

T 
1
LANG:1 5 Apply
"main()
{
	modCreateAiChannels();
}" 0
 E E E
13 58
"cmdClose"
""
1 510 559 E E E 1 E 1 E N "_ButtonText" E N "_Button" E E
 E E
51 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-13-*-100-100-*-*-iso8859-1|-13,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 508 557 582 584

T 
1
LANG:1 5 Close
"main()
{
	PanelOff();
	ModuleOff(\"NodeConfigurationModule\");
}" 0
 E E E
20 59
"chkShowAvailableOnly"
""
1 30 380 E E E 1 E 1 E N "_3DText" E N "_3DFace" E E
 E E
51 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 84 -*-Arial-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,404,0,0,0,0,0,0,0,0,Arial
0 ""
 28 378 212 402
1
T 
1
LANG:1 28 Only show available channels

1 
1
LANG:1 0 
E E
0 0 0 0 0
1
E E
E"main(int button, bool state)
{
// Local Variables
// ---------------
	int iPos;
	
	string sDpName;
	string sPDOdp;
	string sChannel;
	
	dyn_float df;
	
	dyn_string ds;
	dyn_string dsTemp;

// Executable Code
// ---------------
	if (!state) {
		ChildPanelOnCentralReturn(\"vision/MessageInfo\",
															\"Question\",
															makeDynString(\"Unselecting this option is for experts only.\\nAre you sure you want to do it?\", \"Yes\", \"No\"),
															df, ds);
		if (df[1] != 1.0)
			this.state(button) = true;
	}
	
	modCheckValidDP(sDpName);
	iPos = cmbSensorType.selectedPos();
	dpGet(ELMB_SENSOR_INFO_NAME + \".pdoDp\", dsTemp);
	sPDOdp = dsTemp[iPos];
	sChannel = cmbChannelSelector.text;
	modUpdateAvailableChannels(sDpName, sPDOdp, sChannel);
	
	// Return to calling routine
	return;
}" 0
0
LAYER, 1 
1
LANG:1 6 Layer2
0
LAYER, 2 
1
LANG:1 6 Layer3
0
LAYER, 3 
1
LANG:1 6 Layer4
0
LAYER, 4 
1
LANG:1 6 Layer5
0
LAYER, 5 
1
LANG:1 6 Layer6
0
LAYER, 6 
1
LANG:1 6 Layer7
0
LAYER, 7 
1
LANG:1 6 Layer8
0
3 0 "Group2"
"gedi\\EP_enter.ref" 267 466 T 44 1 0 1 283 -396
0
0