V 11
1
LANG:1 0 
PANEL,-1 -1 420 255 N "_3DFace" 1
"$deviceParams"
"main()
{
  dyn_string ex;
  deviceParams = emuui_parseParameterString($deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  
  getValue(\"refPoint\", \"position\", posX, posY);

  // HV status colors and meaning
  hvStatusColors = emuui_getMapping(\"hvStatusColors\", ex);
  if (emu_checkException(ex)) { return; }
  hvStatusTexts = emuui_getMapping(\"hvChannelStatusMeaning\", ex);
  if (emu_checkException(ex)) { return; }
  hvModuleStatusTexts = emuui_getMapping(\"hvModuleStatusMeaning\", ex);
  if (emu_checkException(ex)) { return; }
  
  // Module status
  string moduleStatusDp = emuui_getDpName(\"HV_moduleStatus\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  
  // disabled channels
  string offChannelsDp = emuui_getDpName(\"HV_off_channels\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  
  // module type (if 0 - indicates an LV or signal cable problem)
  string moduleTypeDp = emuui_getDpName(\"HV_moduleType\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  
  // all channels
  dyn_string channelDps;
  emuui_chamberGetHvChannelDps(deviceParams, channelDps, channelsOffset, ex);
  if (emu_checkException(ex)) { return; }

  // find out the \"disconnected devices\" DP to be able to show the \"no communication\" warning
  if (dynlen(channelDps) > 1) {
    deviceParams[\"sysName\"] = emuui_getSystemName(channelDps[1]);
  }
  dyn_string disconnectedDevicesDps = emuui_getDpNames(\"disconnected_devices\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  
  // get the FSM node for the HV of this chamber (this will be used in \"no communication\" warning update
  hvFsmNode = emuui_getFsmNode(\"chamber_high_voltage\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  // add the FSM node
  int fsmX, fsmY;
  dpConnect(\"positionChangedCB\", false, emuui_getSessionDp(\"tooltipPositionUpdated\"));  
  getValue(\"chamber_high_voltage_fsmRefPoint\", \"position\", fsmX, fsmY);
  emuui_addFsmNode(hvFsmNode, fsmX, fsmY, references, true);
  
  // check if the node is disabled, if so - then paint everything in gray and set allGrayMode to true
  string domain = hvFsmNode;
  string object = _fwCU_getNodeObj(domain);
  string duMode = fwFsmUi_getDUMode(domain, object);
  if (duMode == \"Disabled\") {
    allGrayMode = true;
  }

  // get master channel status DP
  mapping masterDeviceParams;
  string masterIdDp = emuui_getDpName(\"HV_moduleToMasterId\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  string masterHostIdDp = emuui_getDpName(\"HV_moduleToMasterHostId\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  string masterHvCardDp = emuui_getDpName(\"HV_moduleToMasterHvCard\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  string masterBusAddressDp = emuui_getDpName(\"HV_moduleToMasterBusAddress\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  string masterChannelDp = emuui_getDpName(\"HV_moduleToMasterChannel\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  
  dpGet(masterIdDp, masterDeviceParams[\"ID\"],
        masterHostIdDp, masterDeviceParams[\"hostId\"],
        masterHvCardDp, masterDeviceParams[\"hvCard\"],
        masterBusAddressDp, masterDeviceParams[\"busAddress\"],
        masterChannelDp, masterDeviceParams[\"channelNumber\"]);
  masterDeviceParams[\"channelNumber\"] += 1;
  string masterChannelStatusDp = emuui_getDpName(\"HV_masterChannelStatus\", masterDeviceParams, ex);
  if (emu_checkException(ex)) { return; }
  lblMasterInfo.text = \"ID=\" + masterDeviceParams[\"ID\"] + \", ch.=\" + masterDeviceParams[\"channelNumber\"];
    
  // init gui and connect everything
  initConsts();
  initGui(dynlen(channelDps), ex);
  if (emu_checkException(ex)) { return; }
  
  for (int i=1; i <= dynlen(channelDps); i++) {
    dynAppend(vMonDps, channelDps[i] + \".vmon\");
    dynAppend(statusDps, channelDps[i] + \".status\");
  }
  
  dpConnect(\"updateDisconnectedWarningCB\", true, disconnectedDevicesDps);
  dpConnect(\"updateVMonCB\", true, vMonDps);
  dpConnect(\"updateStatusCB\", true, statusDps);
  if (!allGrayMode) {
    dpConnect(\"updateDisabledChannelsCB\", true, offChannelsDp);
  }
  dpConnect(\"updateModuleStatusCB\", true, moduleStatusDp);
  dpConnect(\"updateMasterChannelStatusCB\", true, masterChannelStatusDp);
  dpConnect(\"updateModuleTypeCB\", true, moduleTypeDp);
}

void initGui(int channelCount, dyn_string &ex) {  
  //init the vMon table
  int rows = ceil(channelCount / 6);
  
  for (int i=0; i < rows; i++) {
    string rowHeader = \"v\" + ( (i * 6) + 1 ) + \"-\" + \"v\" + ( (i + 1) * 6 ); // e.g. v1-v6 or v7-v12
    tableVoltages.appendLine(\"group1\", \"loading\", \"group2\", \"loading\", \"group3\", \"loading\",
                             \"group4\", \"loading\", \"group5\", \"loading\", \"group6\", \"loading\");
    tableVoltages.rowHeader(i, rowHeader);
  }
  // set proper size for vMon table
  int oldSizeX, oldSizeY, newSizeX, newSizeY;
  getValue(\"tableVoltages\", \"size\", oldSizeX, oldSizeY);
  emuui_tableCompact(\"tableVoltages\", rows);
  getValue(\"tableVoltages\", \"size\", newSizeX, newSizeY);

  // set the module info
  string hvCoordDp = emuui_getDpName(\"HV_coord\", deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  string coordsCombined;
  dpGet(hvCoordDp, coordsCombined);
  dyn_string coords = strsplit(coordsCombined, \";\");
  if (dynlen(coords) == 0) {
    emu_addError(\"Could not get HV module coordinates. This is a sign that one of DCS computers is unreachable (perhaps OFF).\", ex);
    return;
  } else if (dynlen(coords) < 4) {
    emu_addError(\"HV module coordinates are incomplete. DP = \" + hvCoordDp + \". Returned coordinates = \" + coordsCombined, ex);
    return;
  }
  lblModuleInfo.text = \"host=\" + coords[1] + \"; slot=\" + coords[2] + \"; addr=\" + coords[3] + \"; part=\" + coords[4] + \",\";
  
  emuui_repositionObjectRelatively(shapesBelowTable, oldSizeX, oldSizeY, newSizeX, newSizeY);
  int backSizeX, backSizeY;
  getValue(\"chamber_high_voltage_tooltipBack\", \"size\", backSizeX, backSizeY);
  setValue(\"chamber_high_voltage_tooltipBack\", \"size\", backSizeX, backSizeY - (oldSizeY - newSizeY));
  dpSet(emuui_getSessionDp(\"tooltipSizeUpdated\"), 1);
  
  if (allGrayMode) {
    //paint everything in gray
    lblModuleStatus.backCol = \"FwEquipmentDisabled\";
    lblMasterChannelStatus.backCol = \"FwEquipmentDisabled\";
    for (int i=0; i < tableVoltages.lineCount(); i++) {
      for (int j=0; j < tableVoltages.columnCount(); j++) {
        tableVoltages.cellBackColRC(i, tableVoltages.columnToName(j), \"FwEquipmentDisabled\");
      }
    }
  }
}

void initConsts() {
  shapesBelowTable = makeDynString(\"lblForDisabledChannels\", \"lblDisabledChannels\",
                                   \"lblForModuleInfo\", \"lblModuleInfo\", 
                                   \"lblForMasterInfo\", \"lblMasterInfo\");
}" 0
 "main()
{
  emuui_destroyReferences(references);
}" 0
 E E E 1 -1 -1 0  0 0
""0  1
E "//some panel-wide constants
mapping deviceParams;
dyn_string vMonDps, statusDps;
mapping hvStatusColors;
mapping hvStatusTexts;
mapping hvModuleStatusTexts;
int channelsOffset = 0; // offset in module channels that are used by this chamber (e.g. small chambers use channels 1-18 or 19-36 so offset is either 0 or 18 here)
dyn_int currentStatuses;
dyn_int disabledChannels;
string hvFsmNode;
dyn_string references;
int posX, posY;
dyn_string shapesBelowTable;
bool allGrayMode; // this flag is true when the whole LV FSM node is disabled - then back color of the tables is always gray
bool noCommunication;

void updateVMonCB(dyn_string dpList, dyn_float voltages) {
  if (noCommunication) { return; } // don't update the table - let the \"???\" stay there
  
  int rowCount = ceil(dynlen(voltages) / 6);
  
  for (int i=0; i < rowCount; i++) {
    for (int j=1; j <= 6; j++) {
      int arrayIndex = (i * 6) + j;
      if (dynlen(currentStatuses) >= arrayIndex) {
        if (currentStatuses[arrayIndex] > 3) { continue; } // if status flag is > 3 - it's an error state, so don't write voltage
      }
      tableVoltages.cellValueRC(i, \"group\" + j, voltages[arrayIndex] + \" V\");
    }
  }
  
  lblLastUpdate.text = emuui_getLastUpdateTimeOfDpList(dpList);
}

void updateStatusCB(dyn_string dpList, dyn_int statuses) {
  if (noCommunication) { return; } // don't update the table - let the \"???\" and grey color stay there
  
  currentStatuses = statuses;
  int rowCount = ceil(dynlen(statuses) / 6);
  
  for (int i=0; i < rowCount; i++) {
    for (int j=1; j <= 6; j++) {
      int arrayIndex = (i * 6) + j;
      string statusText = hvStatusTexts[(string)statuses[arrayIndex]];
      string statusColor = hvStatusColors[statusText];
      if (!dynContains(disabledChannels, arrayIndex) && !allGrayMode) { // if this channel is disabled - do not update it's color - let it stay gray
        tableVoltages.cellBackColRC(i, \"group\" + j, statusColor);
      }
      if (statuses[arrayIndex] > 3) { // if it's an error state
        tableVoltages.cellValueRC(i, \"group\" + j, statusText);
      }
    }
  }
}

void updateDisabledChannelsCB(string dpName, dyn_string disabledChannelsParam) {
  disabledChannels = disabledChannelsParam;
  for (int i=1; i <= dynlen(disabledChannels); i++) {
    disabledChannels[i] -= channelsOffset;
  }
  if (dynlen(disabledChannels) == 0) {
    lblDisabledChannels.text = \"none\";
    return;
  }
  
  string channelsStr;
  int count = dynlen(disabledChannels);
  for (int i=1; i <= count; i++) {
    int channelNum = disabledChannels[i];
    // construct a label text
    channelsStr += \"#\" + channelNum;
    if (i != count) { // not the last one
      channelsStr += \", \";
    }
    // paint the table cell background
    int row = floor((channelNum - 1) / 6);
    int column = channelNum - (row * 6);
    tableVoltages.cellBackColRC(row, \"group\" + column, \"FwEquipmentDisabled\");
  }
  lblDisabledChannels.text = channelsStr;
}

/** if disconnectedDevices contains hvFsmNode then \"no communication\" warning is shown, otherwise it's hidden. */
void updateDisconnectedWarningCB(dyn_string dps, dyn_string disconnectedDevices) {
  bool isDisconnected = false;
  for (int i=1; i <= dynlen(disconnectedDevices); i++) {
    if (strpos(disconnectedDevices[i], hvFsmNode) >= 0) {
      isDisconnected = true;
      break;
    }
  }
  noCommunication = isDisconnected;
  if (noCommunication) {
    emuui_showTooltipWarning(getShape(\"refPoint\"),
                           getShape(\"warnNoHvCommunication\"), 
                           getShape(\"chamber_high_voltage_tooltipBack\"));
  } else {
    emuui_hideTooltipWarning(getShape(\"warnNoHvCommunication\"), 
                             getShape(\"chamber_high_voltage_tooltipBack\"),
                             makeDynString(\"warnLV\"));
  }
  
  // no communication - display ??? for all values
  if (noCommunication) {
    emuui_questionOutTable(tableVoltages.name());
  }
}

/** If module type comes 0 - this is an indication of LV or signal cable problem - the warning will be shown. */
void updateModuleTypeCB(string dpName, int type) {
  bool lvProblem = (type == 0);
  if (lvProblem) {
    emuui_showTooltipWarning(getShape(\"refPoint\"),
                             getShape(\"warnLV\"), 
                             getShape(\"chamber_high_voltage_tooltipBack\"));
  } else {
    emuui_hideTooltipWarning(getShape(\"warnLV\"), 
                             getShape(\"chamber_high_voltage_tooltipBack\"),
                             \"warnNoHvCommunication\");
  }
}

/** Updates module status. */
void updateModuleStatusCB(string dpName, int status) {
  string statusText = hvModuleStatusTexts[(string)status];
  string statusColor = hvStatusColors[statusText];
  
  lblModuleStatus.text = statusText;
  if (!allGrayMode) {
    lblModuleStatus.backCol = statusColor;
  }
}

/** Updates master channel status. */
void updateMasterChannelStatusCB(string dpName, int status) {
  string statusText = hvStatusTexts[(string)status];
  string statusColor = hvStatusColors[statusText];
  
  lblMasterChannelStatus.text = statusText;
  if (!allGrayMode) {
    lblMasterChannelStatus.backCol = statusColor;
  }
}

void positionChangedCB(string dummyDpName, int dummyValue) {
  emuui_alignSmallFsmNodes(references, makeDynString(\"chamber_high_voltage_fsmRefPoint\"));
}" 0
 2
"CBRef" "1"
"EClose" "main()
{
  emuui_destroyReferences(references);
  PanelOff();
}" 0

""
DISPLAY_LAYER, 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
LAYER, 0 
1
LANG:1 0 
6 31
"chamber_high_voltage_tooltipBack"
""
1 400 40 E E E 1 E 1 E N {0,0,0} E N {255,255,225} E E
 E E
44 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E 3.454545454545452 0 2.222222222222222 -1381.818181818179 -88.8888888888889 1 E 400 40 510 130
2 4
"PRIMITIVE_TEXT1"
""
1 12 10 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
6 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 12 10 85 25
0 2 2 "0s" 0 0 0 192 0 0  12 10 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 12 High Voltage
25 5
"tableVoltages"
""
1 12 59.99999999999999 E E E 1 E 1 E N "_WindowText" E N "_Window" E E
 E E
7 0 0 0 0 0
E E E
0
1
LANG:1 0 

0
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0  10 58 372 152
EE 0 1 1 6 5 "group1" 4 1 0 "s" 1
LANG:1 2 #1
E
1
LANG:1 0 

51 "group2" 4 1 0 "s" 1
LANG:1 2 #2
E
1
LANG:1 0 

51 "group3" 4 1 0 "s" 1
LANG:1 2 #3
E
1
LANG:1 0 

51 "group4" 4 1 0 "s" 1
LANG:1 2 #4
E
1
LANG:1 0 

51 "group5" 4 1 0 "s" 1
LANG:1 2 #5
E
1
LANG:1 0 

51 "group6" 4 1 0 "s" 1
LANG:1 2 #6
E
1
LANG:1 0 

51 
18 18 "" 1 1
LANG:1 5 v1-v6
"" 1 1
LANG:1 6 v7-v12
"" 1 1
LANG:1 7 v13-v18
"" 1 1
LANG:1 7 v19-v24
"" 1 1
LANG:1 7 v25-v30
10 52
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 0 0 0 1 7
1 0
2 7
"lblForDisabledChannels"
""
1 10 160 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
9 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 10 160 117 175
0 2 2 "0s" 0 0 0 192 0 0  10 160 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 18 Disabled channels:
2 8
"lblDisabledChannels"
""
1 120 160 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
10 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
"main()
{
  this.text = \"\";
}" 0
 E 0 1 1 2 1 E U  1 E 120 160 165 175
0 2 2 "0s" 0 0 0 192 0 0  120 160 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 9 list here
2 10
"warnNoHvCommunication"
""
1 10 210 E E E 1 E 0 E N "black" E N "FwStateAttention3" E E
 E E
12 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 10 210 370 224
1 2 2 "0s" 0 0 0 65 0 0  10 210 1
1
LANG:1 25 Arial,9,-1,5,75,0,0,0,0,0
0 1
LANG:1 36 No Communication with this HV module
2 12
"warnLV"
""
1 10 230 E E E 1 E 0 E N "black" E N "FwStateAttention3" E E
 E E
16 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 10 230 370 244
1 2 2 "0s" 0 0 0 65 0 0  10 230 1
1
LANG:1 25 Arial,9,-1,5,75,0,0,0,0,0
0 1
LANG:1 56 High Voltage LV or Signal Cable problem - call HV expert
2 13
"lblLastUpdate"
""
1 270 10 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
18 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 270 10 328 25
0 2 2 "0s" 0 0 0 192 0 0  270 10 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 9 timestamp
2 14
"PRIMITIVE_TEXT6"
""
1 200 10 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
20 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 200 10 269 25
0 2 2 "0s" 0 0 0 192 0 0  200 10 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 12 Last update:
6 16
"chamber_high_voltage_fsmRefPoint"
""
1 110 0 E E E 1 E 0 E N {0,0,0} E N {255,255,255} E E
 E E
24 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E 2.5 0 1 -179 6 1 E 110 0 130 20
7 17
"refPoint"
""
1 140 110 E E E 1 E 0 E N {0,0,0} E N {255,255,255} E E
 E E
26 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E 1 0 1 -140 -110 1 E 140 110 10 10
2 18
"PRIMITIVE_TEXT7"
""
1 12 40 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
27 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 12 40 95 55
0 2 2 "0s" 0 0 0 192 0 0  12 40 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 14 Module Status:
2 19
"PRIMITIVE_TEXT8"
""
1 173 40 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
28 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 173 40 302 55
0 2 2 "0s" 0 0 0 192 0 0  173 40 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 22 Master Channel Status:
2 22
"lblModuleStatus"
""
1 100 40 E E E 1 E 1 E N "_WindowText" E N "FwStateOKPhysics" E E
 E E
31 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 100 40 160 54
1 2 2 "0s" 0 0 0 65 0 0  100 40 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 10 LOADING...
2 26
"lblMasterChannelStatus"
""
1 307 40 E E E 1 E 1 E N "_WindowText" E N "FwStateOKPhysics" E E
 E E
39 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 307 40 367 54
1 2 2 "0s" 0 0 0 65 0 0  307 40 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 10 LOADING...
2 27
"lblForModuleInfo"
""
1 10 180 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
40 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 10 180 79 195
0 2 2 "0s" 0 0 0 192 0 0  10 180 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 13 Module info: 
2 28
"lblForMasterInfo"
""
1 262 180 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
41 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 262 180 304 195
0 2 2 "0s" 0 0 0 192 0 0  262 180 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 7 Master:
2 29
"lblModuleInfo"
""
1 80 180 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
42 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 80 180 261 195
0 2 2 "0s" 0 0 0 192 0 0  80 180 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 33 host=###; slot=#; addr=#; part=#,
2 30
"lblMasterInfo"
""
1 368.5403439648048 300 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 E E
43 0 0 0 0 0
E E E
0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E 0.964285714285714 0 1 22.35714285714295 20 1 E 290 160 359 175
0 2 2 "0s" 0 0 0 192 0 0  290 160 1
1
LANG:1 25 Arial,9,-1,5,50,0,0,0,0,0
0 1
LANG:1 13 ID ##, ch. ##
0
LAYER, 1 
1
LANG:1 0 
0
LAYER, 2 
1
LANG:1 0 
0
LAYER, 3 
1
LANG:1 0 
0
LAYER, 4 
1
LANG:1 0 
0
LAYER, 5 
1
LANG:1 0 
0
LAYER, 6 
1
LANG:1 0 
0
LAYER, 7 
1
LANG:1 0 
0
0
