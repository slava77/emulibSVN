V 10
1
LANG:1 6 Device
PANEL,-1 -1 120 53 N "_3DFace" 5
"$caption"
"$deviceParams"
"$deviceType"
"$group"
"$shapeParams"
"main()
{  
  dyn_string ex;
  deviceParams = emuui_parseParameterString($deviceParams, ex);
  if (emu_checkException(ex)) { return; }  
  
  // is it an ME11?
  if (($deviceType == \"chamber\") && (deviceParams[\"station\"] == 1) && (deviceParams[\"ring\"] == 1)) {
    me11 = true;
    //in ME11 project sides are P & N, not P and M like in others.
    deviceParams[\"side_ME11style\"] = deviceParams[\"side\"];
    if (deviceParams[\"side_ME11style\"] == \"M\") {
      deviceParams[\"side_ME11style\"] = \"N\";
    }
  }
  deviceParamsStr = emuui_mappingToParameterString(deviceParams);
  
  currentConnectionType = \"\";
  currentConnectionMode = \"\";
  currentConnection = \"\";
  hvOffChannelsWarningEnabled = false;
  tooltipRefName = \"refTooltip_\" + $deviceParams;
  
  initShape(ex);
  if (emu_checkException(ex)) { return; }
  
  //by default the physical chamber shape is used
  setValue(shapeName, \"visible\", true);
  if ($caption == \"VALUE\") {
    caption.text = \"\";
    showValueOnCaption = true;
//  } else if (strpos($caption, \"DP=\") == 0) { 
  }else {
    caption.text = $caption;
    showValueOnCaption = false;
  }
  
  if (strlen($group) > 0) {
    dpConnect(\"modeChangedCB\", true, $group + \".mode\", $group + \".connectionType\");
  }
}

void initShape(dyn_string ex) {
  mapping shapeParams = emuui_parseParameterString($shapeParams, ex);
  if (emu_checkException(ex)) { return; }
  
  if (!mappingHasKey(shapeParams, \"type\")) { // if parameters do not include the mandatory \"type\" parameter - error
    emu_addError(\"mandatory 'type' parameter was not found in the $shapeParams parameterString in refDevice.pnl\", ex);
  }
  shapeName = shapeParams[\"type\"];
  
  switch (shapeName) {
    case \"chamber\":
      confChamberShape(shapeParams);
      break;
    case \"rectangle\":
      confRectShape(shapeParams);
      break;
    case \"rectangle_middle_ref_point\":
      confRectShape(shapeParams);
      break;
    default:
      break;
  }
}

void confChamberShape(mapping shapeParams) {
  //check if relevant parameters are present, if not - leave default shape and return
  if (!mappingHasKey(shapeParams, \"innerWidth\") || 
      !mappingHasKey(shapeParams, \"outerWidth\") || 
      !mappingHasKey(shapeParams, \"height\")) {
    
    return;
  }
  
  float innerWidth = shapeParams[\"innerWidth\"],
        outerWidth = shapeParams[\"outerWidth\"],
        height     = shapeParams[\"height\"];
  dyn_dyn_int points; //polygon points
  
  //create the points
  //note: in comments it's assumed that chamber is positioned like this: chamber outer part is on the left and on the right there's inner part of the chamber
  points[1][1] = 0;                          // the bottom left corner X
  points[1][2] = floor(outerWidth / 2) * -1; // the bottom left corner Y
  points[2][1] = 0;                          // the top left corner X
  points[2][2] = ceil(outerWidth / 2);       // the top left corner Y
  points[3][1] = height;                     // the top right corner X
  points[3][2] = ceil(innerWidth / 2);       // the top right corner Y
  points[4][1] = height;                     // the bottom right corner X
  points[4][2] = floor(innerWidth / 2) * -1; // the bottom right corner Y
  
  points[5][1] = points[1][1]; // just to close the polygon
  points[5][2] = points[1][2]; // just to close the polygon
  
  setValue(shapeName, \"points\", points);
  
  if (outerWidth < 15) { caption.visible = false; }
}

void confRectShape(mapping shapeParams) {
  //check if relevant parameters are present, if not - leave default shape and return
  int posX, posY;
  getValue(shapeParams[\"type\"], \"position\", posX, posY);
  if (!mappingHasKey(shapeParams, \"width\") || 
      !mappingHasKey(shapeParams, \"height\")) {
    
    setValue(\"caption\", \"position\", posX + 10, posY + 7);
    return;
  }
  
  posY += ((int)shapeParams[\"height\"]) / 2;
  posX += ((int)shapeParams[\"width\"]) / 2;
  setValue(\"caption\", \"position\", posX, posY);
  
  int width = shapeParams[\"width\"];
  int height = shapeParams[\"height\"];
  setValue(shapeParams[\"type\"], \"size\", width, height); // for some reason a single setSize doesn't set quite the size that you request!!!??? nonsence but it's true - the second setSize does it correctly (discovered when setting size 90px)
  setValue(shapeParams[\"type\"], \"size\", width, height);
  if ((width < 17) || (height < 17)) { 
    caption.visible = false;
  }
}
" 0
 E E E E 1 -1 -1 0  0 0
""0  1
E "//some panel-wide constants
const string EMUUI_REFDEV_TOOLTIP_REF_NAME = \"refTooltip\";
const int EMUUI_REFDEV_TOOLTIP_ON_DELAY_MS = 600;
const int EMUUI_REFDEV_TOOLTIP_OFF_DELAY_MS = 200;
string tooltipRefName;
bool tooltipVisible;
mapping mouseOverObjects;

mapping deviceParams;
string deviceParamsStr;
string shapeName;

string currentConnectionType;
string currentConnectionMode;
string currentConnection;
float currentDpValueRangeMin;
float currentDpValueRangeMax;
bool showValueOnCaption;
bool hvOffChannelsWarningEnabled;
dyn_int disabledHvChannels;
bool me11;
bool isDisabled;


void modeChangedCB(string modeDp, string mode, string connectionTypeDp, string connectionType) {
  dyn_string ex;
  bool connectSuccessful = false;
  isDisabled = false;
  
  //special case for ME11 high voltage
  if (($deviceType == \"chamber\") && (mode == \"high_voltage\") && me11) {
    mode = \"me11_\" + mode;
  }
  
  mode = $deviceType + \"_\" + mode; // prepend mode with device type
  
  setColor(\"white\"); // to indicate busy
  currentConnectionMode = \"busy\";
  
  disconnect();  
    
  // this is an FSM connection
  if (connectionType == \"FSM\") {
    bool nodeFound = false;
    string node = emuui_getFsmNode(mode, deviceParams, ex);
    // node hasn't been found
    if (dynlen(ex) > 0) {
      emu_errorHandled(ex);
    } else if (strlen(node) > 0){
      nodeFound = true;
    }
    
    if (nodeFound) {
//       int rc = fwCU_connectOperationMode(\"updateFSMOperationModeCB\", node);
//       emu_debug(\"RC for connect to operation mode of \" + node + \": \" + rc, emu_DEBUG_DETAIL);
      int rc = fwCU_connectState(\"updateFSMStateCB\", node);
      emu_debug(\"RC for connect to \" + node + \": \" + rc, emu_DEBUG_DETAIL);
      if (rc != 0) { 
        connectSuccessful = true;
        currentConnectionType = connectionType;
        currentConnectionMode = mode;
        currentConnection = node;
      }
    } else {
      emu_debug(\"FSM node was not found for mode '\" + mode + \"' with deviceParams '\" + deviceParams + \"'\");
    }
  } else if (connectionType == \"DP\") { // this is a DP connection
    bool dpFound = false;
    string dp = emuui_getDpName(mode, deviceParams, ex);
    // dp hasn't been found
    if (dynlen(ex) > 0) {
      emu_errorHandled(ex);
    } else if (strlen(dp) > 0){
      dpFound = true;
    }
    
    if (dpFound) {
      currentDpValueRangeMin = emuui_getDpValueRangeMin(mode, ex);
      if (emu_checkException(ex)) { return; }
      currentDpValueRangeMax = emuui_getDpValueRangeMax(mode, ex);
      if (emu_checkException(ex)) { return; }
      int rc = dpConnect(\"updateDPStateCB\", true, dp);
      emu_debug(\"RC for connect to \" + dp + \": \" + rc, emu_DEBUG_DETAIL);
      if (rc == 0) {
        connectSuccessful = true;
        currentConnectionType = connectionType;
        currentConnectionMode = mode;
        currentConnection = dp;
      }
    } else {
      emu_debug(\"DP not found, reporting device as dead. \" +
                \"DP='\" + dp + \"', connection type='\" + connectionType + \"', mode='\" + mode + \"'\", 
                emu_DEBUG_DETAIL);
    }
  }
  
  if (!connectSuccessful) {
    string color = emuui_getMappingValue(\"fsmStateColors\", \"DEAD\", ex);
    if (emu_checkException(ex)) { return; }
    setColor(color);
    currentConnectionType = \"\";
    currentConnection = \"\";
    currentConnectionMode = \"dead\";
  } else { // connection successful
    dyn_string modesWithHvDisabledWarning = emuui_getArray(\"modesWithHvDisabledWarning\", ex);
    if (emu_checkException(ex)) { return; }
    if (dynContains(modesWithHvDisabledWarning, currentConnectionMode)) {
      string dpName = emuui_getDpName(\"HV_off_channels\", deviceParams, ex);
      if (emu_checkException(ex)) { return; }
      if (dpExists(dpName)) {
        hvOffChannelsWarningEnabled = true;
        //TODO need a more generic approach here - probably show the exclamation mark if any (not only HV) channel is excluded (?) i.e. also LV and TEMP, ... maybe also FSM subnodes
        dpConnect(\"updateHVOffChannels\", true, dpName);
      }
    }
  }
}

void updateFSMStateCB(string node, string state) {
  emu_debug(\"state update came for \" + node + \": \" + state);
  // update text
  if (showValueOnCaption) {
    caption.text = state;
  }
  // this device is disabled or excluded - do not update the state color
  if (isDisabled) {
    return;
  }
  // update color
//  dyn_string ex;
//   string color = emuui_getMappingValue(\"fsmStateColors\", state, ex);
//   if (emu_checkException(ex)) { return; }
  string color;
  fwCU_getStateColor(node, state, color);
  if (color == \"\") {
    dyn_string ex;
    color = emuui_getMappingValue(\"fsmStateColors\", state, ex);
    if (emu_checkException(ex)) { return; }
  }
  setColor(color);

}

/** Updates device operation mode. If paramOperationFlag is 0 - that means the device cannot be operated - so it's grayed out. */
void updateFSMOperationModeCB(string node, string paramOperationFlag) {
  bool newIsDisabled = isDisabled;
  if ((paramOperationFlag == 0) && (!newIsDisabled)) {
    newIsDisabled = !emuui_isFsmNodeEnabled(node);
  } else if (paramOperationFlag == 1) {
    newIsDisabled = false;
  }
  
  if ((isDisabled) && (!newIsDisabled)) { // if device just got enabled
    isDisabled = newIsDisabled;
    string state;
    fwCU_getState(node, state);
    updateFSMStateCB(node, state);
  } else if ((!isDisabled) && (newIsDisabled)) { // if device just got disabled
    isDisabled = newIsDisabled;
    setColor(\"FwEquipmentDisabled\");
  }
}

void updateDPStateCB(string dp, float value) {
  emu_debug(\"update came for DP: \" + dp + \": \" + value);
  
  dyn_string ex;
  string color = emuui_getGradientColor(value, currentDpValueRangeMin, currentDpValueRangeMax);
  setColor(color);
  
  if (showValueOnCaption) {
    string captionStr;
    sprintf(captionStr, \"%d\", value);
    caption.text = captionStr;
  }
}

void updateHVOffChannels(string dpName, dyn_string offChannels) {
  disabledHvChannels = offChannels;
  imgHvChannelsDisabled.visible = (dynlen(offChannels) > 0);
}

void disconnect() {
  if (hvOffChannelsWarningEnabled) {
    dyn_string ex;
    hvOffChannelsWarningEnabled = false;
    imgHvChannelsDisabled.visible = false;
    string dpName = emuui_getDpName(\"HV_off_channels\", deviceParams, ex);
    dpDisconnect(\"updateHVOffChannels\", dpName);
  }
  if (currentConnectionType == \"FSM\") {
    fwCU_disconnectState(currentConnection);
  } else if (currentConnectionType == \"DP\") {
    dpDisconnect(\"updateDPStateCB\", currentConnection);
  }
}

void setColor(string color) {
  setValue(shapeName, \"backCol\", color);
}

void showTooltip() {
  if (currentConnectionMode == \"busy\") { return; } // in the process of connecting, don't show any tooltips while in that mode

  delay(0, EMUUI_REFDEV_TOOLTIP_ON_DELAY_MS);  
  if (tooltipVisible || !isMouseOver()) { return; }
  
  int mouseX, mouseY;
  getCursorPosition(mouseX, mouseY);
  string refName = tooltipRefName;
  addSymbol(myModuleName(), myPanelName(),
            \"objects/CMS_CSC_UI/refTooltip.pnl\",
            refName,
            makeDynString(\"$deviceParams:\" + deviceParamsStr, \"$deviceType:\" + $deviceType, \"$mode:\" + currentConnectionMode),
            mouseX, mouseY, 0, 1, 1);
  tooltipVisible = true;
}

void hideTooltip() {
  delay(0, EMUUI_REFDEV_TOOLTIP_OFF_DELAY_MS);
  if (!tooltipVisible || isMouseOver()) { return; }
  
  removeSymbol(myModuleName(), myPanelName(), tooltipRefName);
  tooltipVisible = false;
}

/** If mouse is over any of the objects - this function returns true, if not then false. */
bool isMouseOver() {
  for (int i=1; i <= mappinglen(mouseOverObjects); i++) {
    if (mappingGetValue(mouseOverObjects, i)) {
      return true;
    }
  }
  return false;
}

void showPopupMenu() {
  dyn_string ex;
  emuui_openContextMenu($deviceType, deviceParams, ex);
  if (emu_checkException(ex)) { return; }
  return;
  
  int answer;
  dyn_string menu;
  
//   example of a menu
//   dyn_string menu = makeDynString(\"PUSH_BUTTON, text1, 1, 1\", 
//    \"PUSH_BUTTON, text2, 2, 1\", 
//    \"SEPARATOR\", // separating line 
//    \"CASCADE_BUTTON, Level 2, 1\", // branch 
//    \"PUSH_BUTTON, text3, 3, 1\", 
//    \"Level 2\", // from here level 2 
//    \"PUSH_BUTTON, text4, 4, 0\", 
//    \"PUSH_BUTTON, text5, 5, 1\"); 
  
  int canEnable = 0;
  if (dynlen(disabledHvChannels) > 0) { canEnable = 1; }
  
  dynAppend(menu, \"CASCADE_BUTTON, Recover High Voltage, 1\");
  dynAppend(menu, \"CASCADE_BUTTON, Disable High Voltage Channels, 1\");
  dynAppend(menu, \"CASCADE_BUTTON, Enable High Voltage Channels, \" + canEnable);
    
  // recover submenu
  dynAppend(menu, \"Recover High Voltage\");
  dynAppend(menu, \"PUSH_BUTTON, Recover All Tripped Channels, 100, 1\");
  dynAppend(menu, \"CASCADE_BUTTON, Recover One Channel, 1\");
  dynAppend(menu, \"Recover One Channel\");
  dynAppend(menu, \"PUSH_BUTTON, Recover #3, 103, 1\");
  dynAppend(menu, \"PUSH_BUTTON, Recover #4, 104, 1\");

  //disable submenu
  dynAppend(menu, \"Disable High Voltage Channels\");
  dynAppend(menu, \"PUSH_BUTTON, Disable All Tripped Channels, 200, 1\");
  dynAppend(menu, \"CASCADE_BUTTON, Disable One Channel, 1\");
  dynAppend(menu, \"Disable One Channel\");
  dynAppend(menu, \"PUSH_BUTTON, Disable #3, 203, 1\");
  dynAppend(menu, \"PUSH_BUTTON, Disable #4, 204, 1\");
    
  //enable submenu
  dynAppend(menu, \"Enable High Voltage Channels\");
  dynAppend(menu, \"PUSH_BUTTON, Enable All Disabled Channels, 300, 1\");
  dynAppend(menu, \"CASCADE_BUTTON, Enable One Channel, 1\");
  dynAppend(menu, \"Enable One Channel\");
  for (int i=1; i <= dynlen(disabledHvChannels); i++) {
    dynAppend(menu, \"PUSH_BUTTON, Enable #\" + disabledHvChannels[i] + \", 30\" + disabledHvChannels[i] + \", 1\");
  }
    
    
  string font = \"\";//\"-microsoft windows-Courier New-bold-i-normal-*-*-140-100-100-*-*-iso8859-1\"; //font 
  string forecolor = \"black\"; //foreground color 
  string backcolor = \"white\"; //background color 

  int posX, posY;   
  getCursorPosition(posX, posY);
  //popupMenuXY(menu, posX, posY, answer, font, forecolor, backcolor);
  popupMenu(menu, answer);
  
  emu_info(\"popupso atsakymas: \" + answer);
  if (answer != 0) {
    emu_errorSingle(\"This functionality is not implemented. Please inform DCS expert about this (make sure to describe how you got this message)\");
  }
}
" 0
 2
"CBRef" "1"
"EClose" E
""
DISPLAY_LAYER, 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0
LAYER, 0 
1
LANG:1 0 
10 0
"chamber"
""
1 19.9791666666667 30.0000000000001 E E E 1 E 0 E N {0,0,0} E N {255,255,255} E E
 "main()
{
  showPopupMenu();
}" 0
 "main()
{
//   if ($deviceType != \"chamber\") {
//     return;
//   }
//   string name = \"CSC_ME_\" + deviceParams[\"side\"] + deviceParams[\"station\"] + deviceParams[\"ring\"] + \"_C\" + deviceParams[\"chamberNumber\"];
//   
//   emu_info(\"labas, va name: \" + name);
//   
//   string domain = fwFsm_getAssociatedDomain(name);
//   emu_info(\"domain: \" + domain);
//   string obj = fwFsm_getAssociatedObj(name);
//   emu_info(\"obj: \" + obj);
//   fwUi_showFsmObject(\"CSC_ME_P1\", \"CSC_ME_P1\", \"\");
}" 0

0 0 0 0 0 0
E E "main(bool enter)
{
  mouseOverObjects[this.name] = enter;
  if (enter) {
    showTooltip();
  } else {
    hideTooltip();
  }
}" 0

0
1
LANG:1 0 

3
"hoverfclr" "N \"black_yellow\""
"dashclr"N "_Transparent"
"selectable" ""
E E 0 1 1 1 1 E 0.774020156774913 0 1.02222222222222 -15.4642777155655 -30.6666666666667 1 E 4 19.9791666666667 30.0000000000001
19.9791666666667 69.1304347826089
109.041666666667 61.3043478260871
109.041666666667 39.7826086956523
 1
6 2
"rectangle"
""
1 90 10 E E E 1 E 0 E N {0,0,0} E N {255,255,255} E E
 "main()
{
  showPopupMenu();
}" 0
 E
2 0 0 0 0 0
E E "main(bool enter)
{
  mouseOverObjects[this.name] = enter;
  if (enter) {
    showTooltip();
  } else {
    hideTooltip();
  }
}" 0

0
1
LANG:1 0 

2
"hoverfclr" "N \"black_yellow\""
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E 1 0 1 -90 -10 1 E 90 10 110 30
2 8
"imgHvChannelsDisabled"
""
1 4 21 E E E 1 E 0 E N "_Window" E N "_Transparent" E E
 "main()
{
  showPopupMenu();
}" 0
 E
9 0 0 0 0 0
E E "main(bool enter)
{
  mouseOverObjects[this.name] = enter;
  if (enter) {
    setValue(shapeName, \"foreCol\", \"black_yellow\");
    showTooltip();
  } else {
    setValue(shapeName, \"foreCol\", \"\");
    hideTooltip();
  }
}" 0

0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 0 10 6 35
0 2 2 "0s" 0 0 0 192 0 0  0 10 1
1
LANG:1 101 -*-MS Shell Dlg-bold-r-normal-*-19-*-100-100-*-*-iso8859-1|-19,0,0,0,758,0,0,0,0,0,0,0,0,MS Shell Dlg
0 ""
1
LANG:1 1 !
6 9
"rectangle_middle_ref_point"
""
1 100 10 E E E 1 E 0 E N {0,0,0} E N {255,255,255} E E
 "main()
{
  showPopupMenu();
}" 0
 E
11 0 0 0 0 0
E E "main(bool enter)
{
  mouseOverObjects[this.name] = enter;
  if (enter) {
    showTooltip();
  } else {
    hideTooltip();
  }
}" 0

0
1
LANG:1 0 

2
"hoverfclr" "N \"black_yellow\""
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E 1 0 1 -100 -10 1 E 90 10 110 30
2 1
"caption"
""
1 10 10 E E E 1 E 1 E N "_WindowText" E N "_Transparent" E E
 "main()
{
  showPopupMenu();
}" 0
 E
1 0 0 0 0 0
E E "main(bool enter)
{
  mouseOverObjects[this.name] = enter;
  if (enter) {
    setValue(shapeName, \"foreCol\", \"black_yellow\");
    showTooltip();
  } else {
    setValue(shapeName, \"foreCol\", \"\");
    hideTooltip();
  }
}" 0

0
1
LANG:1 0 

1
"dashclr"N "_Transparent"
E E 0 1 1 2 1 E U  1 E 3 3 17 17
0 2 2 "0s" 0 0 0 193 0 0  10 3 1
1
LANG:1 98 -*-MS Shell Dlg-*-r-normal-*-11-*-100-100-*-*-iso8859-1|-11,0,0,0,505,0,0,0,0,0,0,0,0,MS Shell Dlg
0 ""
1
LANG:1 2 me
0
LAYER, 1 
1
LANG:1 0 
0
LAYER, 2 
1
LANG:1 0 
0
LAYER, 3 
1
LANG:1 0 
0
LAYER, 4 
1
LANG:1 0 
0
LAYER, 5 
1
LANG:1 0 
0
LAYER, 6 
1
LANG:1 0 
0
LAYER, 7 
1
LANG:1 0 
0
0